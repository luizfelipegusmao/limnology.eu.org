{"title":"Request with Intent: Caching Strategies in the Age of PWAs","link":"https://alistapart.com/article/request-with-intent-caching-strategies-in-the-age-of-pwas/","date":1574346606000,"content":"<div id=\"readability-page-1\" class=\"page\"><div><p>Once upon a time, we relied on browsers to handle caching for us; as developers in those days, we had very little control. But then came <a href=\"https://alistapart.com/article/yes-that-web-project-should-be-a-pwa/\">Progressive Web Apps</a> (PWAs), <a href=\"https://developer.mozilla.org/docs/Web/API/Service_Worker_API\">Service Workers</a>, and the <a href=\"https://developer.mozilla.org/docs/Web/API/Cache\">Cache API</a>‚Äîand suddenly we have expansive power over what gets put in the cache and how it gets put there. We can now cache everything we want to‚Ä¶ and therein lies a potential problem.</p><p><span>Article Continues Below</span></p><p>Media files‚Äîespecially images‚Äîmake up <a href=\"https://httparchive.org/reports/page-weight\">the bulk of average page weight</a> these days, and <a href=\"https://httparchive.org/reports/page-weight#bytesImg\">it‚Äôs getting worse</a>. In order to improve performance, it‚Äôs tempting to cache as much of this content as possible, but should we? In most cases, no. Even with all this newfangled technology at our fingertips, great performance still hinges on a simple rule: <a href=\"https://alistapart.com/article/the-best-request-is-no-request-revisited\">request only what you need and make each request as small as possible</a>.</p><p>To provide the best possible experience for our users without abusing their network connection or their hard drive, it‚Äôs time to put a spin on some classic best practices, experiment with media caching strategies, and play around with a few Cache API tricks that Service Workers have hidden up their sleeves.</p><h2 id=\"section2\">Best intentions<a href=\"#section2\">#section2</a></h2><p>All those lessons we learned optimizing web pages for dial-up became super-useful again when mobile took off, and they continue to be applicable in the work we do for a global audience today. Unreliable or high latency network connections are still the norm in many parts of the world, reminding us that it‚Äôs never safe to assume a technical baseline lifts evenly or in sync with its corresponding cutting edge. And that‚Äôs the thing about performance best practices: history has borne out that approaches that are good for performance now will continue being good for performance in the future.</p><p>Before the advent of Service Workers, we could provide <a href=\"https://developer.yahoo.com/performance/rules.html#expires\">some instructions to browsers</a> with respect to how long they should cache a particular resource, but that was about it. Documents and assets downloaded to a user‚Äôs machine would be dropped into a directory on their hard drive. When the browser assembled a request for a particular document or asset, it would peek in the cache first to see if it already had what it needed to possibly avoid hitting the network.</p><p>We have considerably more control over network requests and the cache these days, but that doesn‚Äôt excuse us from being thoughtful about the resources on our web pages.</p><h3 id=\"section3\">Request only what you need<a href=\"#section3\">#section3</a></h3><p>As I mentioned, the web today is lousy with media. Images and videos have become a dominant means of communication. They may convert well when it comes to sales and marketing, but they are hardly performant when it comes to download and rendering speed. With this in mind, each and every image (and video, etc.) should have to fight for its place on the page.&nbsp;</p><p>A few years back, a recipe of mine was included in a newspaper story on cooking with spirits (alcohol, not ghosts). I don‚Äôt subscribe to the print version of that paper, so when the article came out I went to the site to take a look at how it turned out. During a recent redesign, the site had decided to load all articles into a nearly full-screen modal viewbox layered on top of their homepage. This meant requesting the article required requests for all of the assets associated with the article page <em>plus</em> all the contents and assets for the homepage. Oh, and the homepage had video ads‚Äîplural. And, yes, they auto-played.</p><p>I popped open DevTools and discovered the page had blown past 15 MB in page weight. Tim Kadlec had recently launched <a href=\"https://whatdoesmysitecost.com/\">What Does My Site Cost?</a>, so I decided to check out the damage. Turns out that the actual cost to view that page for the average US-based user was more than the cost of the print version of that day‚Äôs newspaper. That‚Äôs just messed up.</p><p>Sure, I could blame the folks who built the site for doing their readers such a disservice, but the reality is that none of us go to work with the goal of worsening our users‚Äô experiences. This could happen to any of us. We could spend days scrutinizing the performance of a page only to have some committee decide to set that carefully crafted page atop a Times Square of auto-playing video ads. Imagine how much worse things would be if we were stacking two abysmally-performing pages on top of each other!</p><p>Media can be great for drawing attention when competition is high (e.g., on the homepage of a newspaper), but when you want readers to focus on a single task (e.g., reading the actual article), its value can drop from important to ‚Äúnice to have.‚Äù Yes, studies have shown that images excel at drawing eyeballs, but once a visitor is on the article page, <a href=\"https://theoutline.com/post/2485/not-every-article-needs-a-picture\">no one cares</a>; we‚Äôre just making it take longer to download and more expensive to access. The situation only gets worse as we shove more media into the page.&nbsp;</p><p>We must do everything in our power to reduce the weight of our pages, so avoid requests for things that don‚Äôt add value. For starters, if you‚Äôre writing an article about a data breach, resist the urge to include <a href=\"https://www.istockphoto.com/jp/en/photo/hacker-attacking-internet-gm540848970-96658127\">that ridiculous stock photo</a> of some random dude in a hoodie typing on a computer in a very dark room.</p><h3 id=\"section4\">Request the smallest file you can<a href=\"#section4\">#section4</a></h3><p>Now that we‚Äôve taken stock of what we <em>do</em> need to include, we must ask ourselves a critical question: How can we deliver it in the fastest way possible? This can be as simple as <a href=\"https://vimeo.com/290141511\">choosing the most appropriate image format</a> for the content presented (and optimizing the heck out of it) or as complex as recreating assets entirely (for example, if switching from raster to vector imagery would be more efficient).</p><h4 id=\"section5\">Offer alternate formats<a href=\"#section5\">#section5</a></h4><p>When it comes to image formats, we don‚Äôt have to choose between performance and reach anymore. We can provide multiple options and let <em>the browser</em> decide which one to use, based on what it can handle.</p><p>You can accomplish this by offering multiple <code>sources</code> within a <code>picture</code> or <code>video</code> element. Start by creating multiple formats of the media asset. For example, with WebP and JPG, it‚Äôs likely that the WebP will have a smaller file size than the JPG (but check to make sure). With those alternate sources, you can drop them into a <code>picture</code> like this:</p><figure id=\"figure1\"><pre id=\"snippet1\"><code><span><span><span>&lt;</span>picture</span><span>&gt;</span></span>\n  <span><span><span>&lt;</span>source</span> <span>srcset</span><span><span>=</span><span>\"</span>my.webp<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>image/webp<span>\"</span></span><span>&gt;</span></span>\n  <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>\"</span>my.jpg<span>\"</span></span> <span>alt</span><span><span>=</span><span>\"</span>Descriptive text about the picture.<span>\"</span></span><span>&gt;</span></span>\n<span><span><span>&lt;/</span>picture</span><span>&gt;</span></span></code></pre></figure><p>Browsers that recognize the <code>picture</code> element will check the <code>source</code> element before making a decision about which image to request. If the browser supports the MIME type ‚Äúimage/webp,‚Äù it will kick off a request for the WebP format image. If not (or if the browser doesn‚Äôt recognize <code>picture</code>), it will request the JPG.&nbsp;</p><p>The nice thing about this approach is that you‚Äôre serving the smallest image possible to the user without having to resort to any sort of JavaScript hackery.</p><p>You can take the same approach with video files:</p><figure id=\"figure2\"><pre id=\"snippet2\"><code><span><span><span>&lt;</span>video</span> <span>controls</span><span>&gt;</span></span>\n  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>\"</span>my.webm<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>video/webm<span>\"</span></span><span>&gt;</span></span>\n  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>\"</span>my.mp4<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>video/mp4<span>\"</span></span><span>&gt;</span></span>\n  <span><span><span>&lt;</span>p</span><span>&gt;</span></span>Your browser doesn‚Äôt support native video playback,\n    but you can <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>my.mp4<span>\"</span></span> <span>download</span><span>&gt;</span></span>download<span><span><span>&lt;/</span>a</span><span>&gt;</span></span>\n    this video instead.<span><span><span>&lt;/</span>p</span><span>&gt;</span></span>\n<span><span><span>&lt;/</span>video</span><span>&gt;</span></span></code></pre></figure><p>Browsers that support WebM will request the first <code>source</code>, whereas browsers that don‚Äôt‚Äîbut do understand MP4 videos‚Äîwill request the second one. Browsers that don‚Äôt support the <code>video</code> element will fall back to the paragraph about downloading the file.</p><p>The order of your <code>source</code> elements matters. <a href=\"https://html.spec.whatwg.org/multipage/media.html#concept-media-load-algorithm\">Browsers will choose the first <em>usable</em> <code>source</code></a>, so if you specify an optimized alternative format <em>after</em> a more widely compatible one, the alternative format may never get picked up.&nbsp;&nbsp;</p><p>Depending on your situation, you might consider bypassing this markup-based approach and handle things on the server instead. For example, if a JPG is being requested and the browser supports WebP (which is indicated in the <code>Accept</code> header), there‚Äôs nothing stopping you from replying with a WebP version of the resource. In fact, some CDN services‚Äî<a href=\"https://cloudinary.com/\">Cloudinary</a>, for instance‚Äîcome with this sort of functionality right out of the box.</p><h4 id=\"section6\">Offer different sizes<a href=\"#section6\">#section6</a></h4><p>Formats aside, you may want to deliver alternate image sizes optimized for the current size of the browser‚Äôs viewport. After all, there‚Äôs no point loading an image that‚Äôs 3‚Äì4 times larger than the screen rendering it; that‚Äôs just wasting bandwidth. This is where <a href=\"https://alistapart.com/article/responsive-images-in-practice/\">responsive images</a> come in.</p><p>Here‚Äôs an example:</p><figure id=\"figure3\"><pre id=\"snippet3\"><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>\"</span>medium.jpg<span>\"</span></span>\n  <span>srcset</span><span><span>=</span><span>\"</span>small.jpg 256w,\n    medium.jpg 512w,\n    large.jpg 1024w<span>\"</span></span>\n  <span>sizes</span><span><span>=</span><span>\"</span>(min-width: 30em) 30em, 100vw<span>\"</span></span>\n  <span>alt</span><span><span>=</span><span>\"</span>Descriptive text about the picture.<span>\"</span></span><span>&gt;</span></span></code></pre></figure><p>There‚Äôs a lot going on in this super-charged <code>img</code> element, so I‚Äôll break it down:</p><ul><li>This <code>img</code> offers three size options for a given JPG: 256‚Äâpx wide (<code>small.jpg</code>), 512‚Äâpx wide (<code>medium.jpg</code>), and 1024‚Äâpx wide (<code>large.jpg</code>). These are provided in the <code>srcset</code> attribute with corresponding <a href=\"https://cloudfour.com/thinks/responsive-images-101-part-4-srcset-width-descriptors/\">width descriptors</a>.</li><li>The <code>src</code> defines a default image source, which acts as a fallback for browsers that don‚Äôt support <code>srcset</code>. Your choice for the default image will likely depend on the context and general usage patterns. Often I‚Äôd recommend the smallest image be the default, but if the majority of your traffic is on older desktop browsers, you might want to go with the medium-sized image.</li><li>The <code>sizes</code> attribute is a <a href=\"https://www.w3.org/TR/CSS2/cascade.html#preshint\">presentational hint</a> that informs the browser how the image will be rendered in different scenarios (its <a href=\"https://24ways.org/2018/jank-free-image-loads/\">extrinsic size</a>) once CSS has been applied. This particular example says that the image will be the full width of the viewport (<code>100vw</code>) until the viewport reaches 30‚Äâem in width (<code>min-width: 30em</code>), at which point the image will be 30‚Äâem wide. You can make the <code>sizes</code> value as complicated or as simple as you want; omitting it causes browsers to use the default value of <code>100vw</code>.</li></ul><p>You can even combine this approach with <a href=\"https://alistapart.com/article/responsive-images-in-practice/#snippet13\">alternate formats and crops within a single <code>picture</code></a>. <img draggable=\"false\" role=\"img\" alt=\"ü§Ø\" src=\"https://s.w.org/images/core/emoji/13.0.1/svg/1f92f.svg\"></p><p>All of this is to say that you have a number of tools at your disposal for delivering fast-loading media, so use them!</p><h2 id=\"section7\">Defer requests (when possible)<a href=\"#section7\">#section7</a></h2><p>Years ago, Internet Explorer 11 introduced a new attribute that enabled developers to de-prioritize specific <code>img</code> elements to speed up page rendering: <code>lazyload</code>. That attribute never went anywhere, standards-wise, but it was a solid attempt to defer image loading until images are in view (or close to it) without having to involve JavaScript.</p><p>There have been countless JavaScript-based implementations of lazy loading images since then, but recently Google also took a stab at a more declarative approach, using a different attribute: <a href=\"https://web.dev/native-lazy-loading\"><code>loading</code></a>.</p><p>The <code>loading</code> attribute supports three values (‚Äúauto,‚Äù ‚Äúlazy,‚Äù and ‚Äúeager‚Äù) to define how a resource should be brought in. For our purposes, the ‚Äúlazy‚Äù value is the most interesting because it defers loading the resource until it reaches a <a href=\"https://web.dev/native-lazy-loading#load-in-distance-threshold\">calculated distance</a> from the viewport.</p><p>Adding that into the mix‚Ä¶</p><figure id=\"figure4\"><pre id=\"snippet4\"><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>\"</span>medium.jpg<span>\"</span></span>\n  <span>srcset</span><span><span>=</span><span>\"</span>small.jpg 256w,\n    medium.jpg 512w,\n    large.jpg 1024w<span>\"</span></span>\n  <span>sizes</span><span><span>=</span><span>\"</span>(min-width: 30em) 30em, 100vw<span>\"</span></span>\n  <span>loading</span><span><span>=</span><span>\"</span>lazy<span>\"</span></span>\n  <span>alt</span><span><span>=</span><span>\"</span>Descriptive text about the picture.<span>\"</span></span><span>&gt;</span></span></code></pre></figure><p>This attribute offers a bit of a performance boost in Chromium-based browsers. Hopefully it will become a standard and get picked up by other browsers in the future, but in the meantime there‚Äôs no harm in including it because browsers that don‚Äôt understand the attribute will simply ignore it.</p><p>This approach complements a media prioritization strategy really well, but before I get to that, I want to take a closer look at Service Workers.</p><h2 id=\"section8\">Manipulate requests in a Service Worker<a href=\"#section8\">#section8</a></h2><p>Service Workers are a special type of <a href=\"https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers\">Web Worker</a> with the ability to intercept, modify, and respond to all network requests via the <a href=\"https://developer.mozilla.org/docs/Web/API/Fetch_API\">Fetch API</a>. They also have access to the <a href=\"https://developer.mozilla.org/docs/Web/API/Cache\">Cache API</a>, as well as other asynchronous client-side data stores like <a href=\"https://developer.mozilla.org/docs/Web/API/IndexedDB_API\">IndexedDB</a> for resource storage.</p><p>When a Service Worker is installed, you can hook into that event and prime the cache with resources you want to use later. Many folks use this opportunity to squirrel away copies of global assets, including styles, scripts, logos, and the like, but you can also use it to cache images for use when network requests fail.</p><h3 id=\"section9\">Keep a fallback image in your back pocket<a href=\"#section9\">#section9</a></h3><p>Assuming you want to use a fallback in more than one networking recipe, you can set up a named function that will respond with that resource:</p><figure id=\"figure5\"><pre id=\"snippet5\"><code><span>function</span> respondWithFallbackImage<span>(</span><span>)</span> <span>{</span>\n  <span>return</span> caches<span>.</span>match<span>(</span> <span>\"/i/fallbacks/offline.svg\"</span> <span>)</span><span>;</span>\n<span>}</span></code></pre></figure><p>Then, within a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent\"><code>fetch</code> event handler</a>, you can use that function to provide that fallback image when requests for images fail at the network:</p><figure id=\"figure6\"><pre id=\"snippet6\"><code>self<span>.</span>addEventListener<span>(</span> <span>\"fetch\"</span><span>,</span> event <span>=&gt;</span> <span>{</span>\n  const request <span>=</span> event<span>.</span>request<span>;</span>\n  <span>if</span> <span>(</span> request<span>.</span>headers<span>.</span>get<span>(</span><span>\"Accept\"</span><span>)</span><span>.</span>includes<span>(</span><span>\"image\"</span><span>)</span> <span>)</span> <span>{</span>\n    event<span>.</span>respondWith<span>(</span>\n      <span>return</span> fetch<span>(</span> request<span>,</span> <span>{</span> mode<span>:</span> <span>'no-cors'</span> <span>}</span> <span>)</span>\n        <span>.</span>then<span>(</span> response <span>=&gt;</span> <span>{</span>\n          <span>return</span> response<span>;</span>\n        <span>}</span><span>)</span>\n        <span>.</span><span>catch</span><span>(</span>\n          respondWithFallbackImage\n        <span>)</span><span>;</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span></code></pre></figure><p>When the network is available, users get the expected behavior:</p><figure id=\"figure7\"><img loading=\"lazy\" width=\"960\" height=\"396\" src=\"https://alistapart.com/wp-content/uploads/2019/11/fig1.png?w=960&amp;resize=960%2C396\" alt=\"Screenshot of a component showing a series of user profile images of users who have liked something\" data-recalc-dims=\"1\"><figcaption>Social media avatars are rendered as expected when the network is available.</figcaption></figure><p>But when the network is interrupted, images will be swapped automatically for a fallback, and the user experience is still acceptable:</p><figure id=\"figure8\"><img loading=\"lazy\" width=\"960\" height=\"394\" src=\"https://alistapart.com/wp-content/uploads/2019/11/fig2-1.png?w=960&amp;resize=960%2C394\" alt=\"Screenshot showing a series of identical generic user images in place of the individual ones which have not loaded\" data-recalc-dims=\"1\"><figcaption>A generic fallback avatar is rendered when the network is unavailable.</figcaption></figure><p>On the surface, this approach may not seem all that helpful in terms of performance since you‚Äôve essentially added an additional image download into the mix. With this system in place, however, some pretty amazing opportunities open up to you.</p><h3 id=\"section10\">Respect a user‚Äôs choice to save data<a href=\"#section10\">#section10</a></h3><p>Some users reduce their data consumption by entering a ‚Äúlite‚Äù mode or turning on a ‚Äúdata saver‚Äù feature. When this happens, browsers will often send a <a href=\"https://developer.mozilla.org/docs/Web/HTTP/Headers/Save-Data\"><code>Save-Data</code> header</a> with their network requests.&nbsp;</p><p>Within your Service Worker, you can look for this header and adjust your responses accordingly. First, you look for the header:</p><figure id=\"figure9\"><pre id=\"snippet7\"><code><span>let</span> save_data <span>=</span> <span>false</span><span>;</span>\n<span>if</span> <span>(</span> <span>'connection'</span> <span>in</span> navigator <span>)</span> <span>{</span>\n  save_data <span>=</span> navigator<span>.</span>connection<span>.</span>saveData<span>;</span>\n<span>}</span></code></pre></figure><p>Then, within your <code>fetch</code> handler for images, you might choose to preemptively respond with the fallback image instead of going to the network at all:</p><figure id=\"figure10\"><pre id=\"snippet8\"><code>self<span>.</span>addEventListener<span>(</span> <span>\"fetch\"</span><span>,</span> event <span>=&gt;</span> <span>{</span>\n  const request <span>=</span> event<span>.</span>request<span>;</span>\n  <span>if</span> <span>(</span> request<span>.</span>headers<span>.</span>get<span>(</span><span>\"Accept\"</span><span>)</span><span>.</span>includes<span>(</span><span>\"image\"</span><span>)</span> <span>)</span> <span>{</span>\n    event<span>.</span>respondWith<span>(</span>\n      <span>if</span> <span>(</span> save_data <span>)</span> <span>{</span>\n        <span>return</span> respondWithFallbackImage<span>(</span><span>)</span><span>;</span>\n      <span>}</span>\n      <span spellcheck=\"true\">// code you saw previously\n</span>    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span></code></pre></figure><p>You could even take this a step further and tune <code>respondWithFallbackImage()</code> to provide alternate images based on what the original request was for. To do that you‚Äôd define several fallbacks globally in the Service Worker:</p><figure id=\"figure11\"><pre id=\"snippet9\"><code>const fallback_avatar <span>=</span> <span>\"/i/fallbacks/avatar.svg\"</span><span>,</span>\n      fallback_image <span>=</span> <span>\"/i/fallbacks/image.svg\"</span><span>;</span></code></pre></figure><p>Both of those files should then be cached during the Service Worker install event:</p><figure id=\"figure12\"><pre id=\"snippet10\"><code><span>return</span> cache<span>.</span>addAll<span>(</span> <span>[</span>\n  fallback_avatar<span>,</span>\n  fallback_image\n<span>]</span><span>)</span><span>;</span></code></pre></figure><p>Finally, within <code>respondWithFallbackImage()</code> you could serve up the appropriate image based on the URL being fetched. In my site, the avatars are pulled from <a href=\"https://webmention.io/\">Webmention.io</a>, so I test for that.</p><figure id=\"figure13\"><pre id=\"snippet11\"><code><span>function</span> respondWithFallbackImage<span>(</span> url <span>)</span> <span>{</span>\n  const image <span>=</span> avatars<span>.</span>test<span>(</span> <span>/webmention\\.io/</span> <span>)</span> <span>?</span> fallback_avatar\n                                                 <span>:</span> fallback_image<span>;</span>\n  <span>return</span> caches<span>.</span>match<span>(</span> image <span>)</span><span>;</span>\n<span>}</span></code></pre></figure><p>With that change, I‚Äôll need to update the <code>fetch</code> handler to pass in <code>request.url</code> as an argument to <code>respondWithFallbackImage()</code>. Once that‚Äôs done, when the network gets interrupted I end up seeing something like this:</p><figure id=\"figure14\"><img loading=\"lazy\" width=\"960\" height=\"1012\" src=\"https://alistapart.com/wp-content/uploads/2019/11/fig3.png?w=960&amp;resize=960%2C1012\" alt=\"Screenshot showing a blog comment with a generic user profile image and image placeholder where the network could not load the actual images\" data-recalc-dims=\"1\"><figcaption>A webmention that contains both an avatar and an embedded image will render with two different fallbacks when the Save-Data header is present.</figcaption></figure><p>Next, we need to establish some general guidelines for handling media assets‚Äîbased on the situation, of course.</p><h3 id=\"section11\">The caching strategy: prioritize certain media<a href=\"#section11\">#section11</a></h3><p>In my experience, media‚Äîespecially images‚Äîon the web tend to fall into three categories of necessity. At one end of the spectrum are elements that don‚Äôt add meaningful value. At the other end of the spectrum are critical assets that <em>do</em> add value, such as charts and graphs that are essential to understanding the surrounding content. Somewhere in the middle are what I would call ‚Äúnice-to-have‚Äù media. They <em>do</em> add value to the core experience of a page but are not critical to understanding the content.</p><p>If you consider your media with this division in mind, you can establish some general guidelines for handling each, based on the situation. In other words, a caching strategy.</p><figure id=\"figure15\"><table><caption>Media loading strategy, broken down by how critical an asset is to understanding an interface</caption><thead><tr><th scope=\"col\">Media category</th><th scope=\"col\">Fast connection</th><th scope=\"col\"><code>Save-Data</code></th><th scope=\"col\">Slow connection</th><th scope=\"col\">No network</th></tr></thead><tbody><tr><td data-title=\"Media category\"><b>Critical</b></td><td colspan=\"3\" data-title=\"Fast connection, Save-Data, Slow Connection\">Load media</td><td data-title=\"No network\">Replace with placeholder</td></tr><tr><td data-title=\"Media category\"><b>Nice-to-have</b></td><td data-title=\"Fast connection\">Load media</td><td colspan=\"3\" data-title=\"Save-Data, Slow connection, No network\">Replace with placeholder</td></tr><tr><td data-title=\"Media category\"><b>Non-critical</b></td><td colspan=\"4\" data-title=\"Fast connection, Save-Data, Slow connection, No network\">Remove from content entirely</td></tr></tbody></table></figure><p>When it comes to disambiguating the critical from the nice-to-have, it‚Äôs helpful to have those resources organized into separate directories (or similar). That way we can add some logic into the Service Worker that can help it decide which is which. For example, on my own personal site, critical images are either self-hosted or come from the website for <a href=\"https://adaptivewebdesign.info/\">my book</a>. Knowing that, I can write regular expressions that match those domains:</p><figure id=\"figure16\"><pre id=\"snippet12\"><code>const high_priority <span>=</span> <span>[</span>\n    <span>/aaron\\-gustafson\\.com/</span><span>,</span>\n    <span>/adaptivewebdesign\\.info/</span>\n  <span>]</span><span>;</span></code></pre></figure><p>With that <code>high_priority</code> variable defined, I can create a function that will let me know if a given image request (for example) is a high priority request or not:</p><figure id=\"figure17\"><pre id=\"snippet13\"><code><span>function</span> isHighPriority<span>(</span> url <span>)</span> <span>{</span>\n  <span spellcheck=\"true\">// how many high priority links are we dealing with?\n</span>  <span>let</span> i <span>=</span> high_priority<span>.</span>length<span>;</span>\n  <span spellcheck=\"true\">// loop through each\n</span>  <span>while</span> <span>(</span> i<span>--</span> <span>)</span> <span>{</span>\n    <span spellcheck=\"true\">// does the request URL match this regular expression?\n</span>    <span>if</span> <span>(</span> high_priority<span>[</span>i<span>]</span><span>.</span>test<span>(</span> url <span>)</span> <span>)</span> <span>{</span>\n      <span spellcheck=\"true\">// yes, it‚Äôs a high priority request\n</span>      <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span spellcheck=\"true\">// no matches, not high priority\n</span>  <span>return</span> <span>false</span><span>;</span>\n<span>}</span></code></pre></figure><p>Adding support for prioritizing media requests only requires adding a new conditional into the <code>fetch</code> event handler, like we did with <code>Save-Data</code>. Your specific recipe for network and cache handling will likely differ, but here was <a href=\"https://github.com/aarongustafson/aaron-gustafson.com/blob/master/_javascript/serviceworker/fetch.js#L162-L219\">how I chose to mix in this logic within image requests</a>:</p><figure id=\"figure18\"><pre id=\"snippet14\"><code><span spellcheck=\"true\">// Check the cache first\n</span> <span spellcheck=\"true\"> // Return the cached image if we have one\n</span> <span spellcheck=\"true\"> // If the image is not in the cache, continue\n</span><span spellcheck=\"true\">\n// Is this image high priority?\n</span><span>if</span> <span>(</span> isHighPriority<span>(</span> url <span>)</span> <span>)</span> <span>{</span>\n\n <span spellcheck=\"true\"> // Fetch the image\n</span>   <span spellcheck=\"true\"> // If the fetch succeeds, save a copy in the cache\n</span>   <span spellcheck=\"true\"> // If not, respond with an \"offline\" placeholder\n</span><span spellcheck=\"true\">\n// Not high priority\n</span><span>}</span> <span>else</span> <span>{</span>\n\n <span spellcheck=\"true\"> // Should I save data?\n</span>  <span>if</span> <span>(</span> save_data <span>)</span> <span>{</span>\n\n   <span spellcheck=\"true\"> // Respond with a \"saving data\" placeholder\n</span>\n <span spellcheck=\"true\"> // Not saving data\n</span>  <span>}</span> <span>else</span> <span>{</span>\n\n   <span spellcheck=\"true\"> // Fetch the image\n</span>     <span spellcheck=\"true\"> // If the fetch succeeds, save a copy in the cache\n</span>     <span spellcheck=\"true\"> // If not, respond with an \"offline\" placeholder\n</span>  <span>}</span>\n<span>}</span></code></pre></figure><p>We can apply this prioritized approach to many kinds of assets. We could even use it to control which pages are served cache-first vs. network-first.</p><h2 id=\"section12\">Keep the cache tidy<a href=\"#section12\">#section12</a></h2><p>The&nbsp; ability to control which resources are cached to disk is a huge opportunity, but it also carries with it an equally huge responsibility not to abuse it.</p><p>Every caching strategy is likely to differ, at least a little bit. If we‚Äôre publishing a book online, for instance, it might make sense to cache all of the chapters, images, etc. for offline viewing. There‚Äôs a fixed amount of content and‚Äîassuming there aren‚Äôt a ton of heavy images and videos‚Äîusers will benefit from not having to download each chapter separately.</p><p>On a news site, however, caching every article and photo will quickly fill up our users‚Äô hard drives. If a site offers an indeterminate number of pages and assets, it‚Äôs <em>critical</em> to have a caching strategy that puts hard limits on how many resources we‚Äôre caching to disk.&nbsp;</p><p>One way to do this is to create several different blocks associated with caching different forms of content. The more ephemeral content caches can have strict limits around how many items can be stored. Sure, we‚Äôll still be bound to the storage limits of the device, but do we really want our website to take up 2 GB of someone‚Äôs hard drive?</p><p>Here‚Äôs an example, again from my own site:</p><figure id=\"figure19\"><pre id=\"snippet15\"><code>const sw_caches <span>=</span> <span>{</span>\n  static<span>:</span> <span>{</span>\n    name<span>:</span> `$<span>{</span>version<span>}</span>static`\n  <span>}</span><span>,</span>\n  images<span>:</span> <span>{</span>\n    name<span>:</span> `$<span>{</span>version<span>}</span>images`<span>,</span>\n    limit<span>:</span> <span>75</span>\n  <span>}</span><span>,</span>\n  pages<span>:</span> <span>{</span>\n    name<span>:</span> `$<span>{</span>version<span>}</span>pages`<span>,</span>\n    limit<span>:</span> <span>5</span>\n  <span>}</span><span>,</span>\n  other<span>:</span> <span>{</span>\n    name<span>:</span> `$<span>{</span>version<span>}</span>other`<span>,</span>\n    limit<span>:</span> <span>50</span>\n  <span>}</span>\n<span>}</span></code></pre></figure><p>Here I‚Äôve defined several caches, each with a <code>name</code> used for addressing it in the Cache API and a <code>version</code> prefix. The <code>version</code> is defined elsewhere in the Service Worker, and allows me to purge all caches at once if necessary.</p><p>With the exception of the <code>static</code> cache, which is used for static assets, every cache has a <code>limit</code> to the number of items that may be stored. I only cache the most recent 5 pages someone has visited, for instance. Images are limited to the most recent 75, and so on. This is an approach that <a href=\"https://adactio.com/\">Jeremy Keith</a> outlines in his fantastic book <a href=\"https://abookapart.com/products/going-offline\"><em>Going Offline</em></a> (which you should really read if you haven‚Äôt already‚Äî<a href=\"https://alistapart.com/article/going-offline/\">here‚Äôs a sample</a>).</p><p>With these cache definitions in place, I can clean up my caches periodically and prune the oldest items. Here‚Äôs Jeremy‚Äôs recommended code for this approach:</p><figure id=\"figure20\"><pre id=\"snippet16\"><code><span>function</span> trimCache<span>(</span>cacheName<span>,</span> maxItems<span>)</span> <span>{</span>\n  <span spellcheck=\"true\">// Open the cache\n</span>  caches<span>.</span>open<span>(</span>cacheName<span>)</span>\n  <span>.</span>then<span>(</span> cache <span>=&gt;</span> <span>{</span>\n    <span spellcheck=\"true\">// Get the keys and count them\n</span>    cache<span>.</span>keys<span>(</span><span>)</span>\n    <span>.</span>then<span>(</span>keys <span>=&gt;</span> <span>{</span>\n      <span spellcheck=\"true\">// Do we have more than we should?\n</span>      <span>if</span> <span>(</span>keys<span>.</span>length <span>&gt;</span> maxItems<span>)</span> <span>{</span>\n        <span spellcheck=\"true\">// Delete the oldest item and run trim again\n</span>        cache<span>.</span>delete<span>(</span>keys<span>[</span><span>0</span><span>]</span><span>)</span>\n        <span>.</span>then<span>(</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>\n          trimCache<span>(</span>cacheName<span>,</span> maxItems<span>)</span>\n        <span>}</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span></code></pre></figure><p>We can trigger this code to run whenever a new page loads. By running it in the Service Worker, it runs in a separate thread and won‚Äôt drag down the site‚Äôs responsiveness. We trigger it by posting a message (using <code>postMessage()</code>) to the Service Worker from the main JavaScript thread:</p><figure id=\"figure21\"><pre id=\"snippet17\"><code><span spellcheck=\"true\">// First check to see if you have an active service worker\n</span><span>if</span> <span>(</span> navigator<span>.</span>serviceWorker<span>.</span>controller <span>)</span> <span>{</span>\n <span spellcheck=\"true\"> // Then add an event listener\n</span>  window<span>.</span>addEventListener<span>(</span> <span>\"load\"</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n   <span spellcheck=\"true\"> // Tell the service worker to clean up\n</span>    navigator<span>.</span>serviceWorker<span>.</span>controller<span>.</span>postMessage<span>(</span> <span>\"clean up\"</span> <span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span></code></pre></figure><p>The final step in wiring it all up is setting up the Service Worker to receive the message:</p><figure id=\"figure22\"><pre id=\"snippet18\"><code>addEventListener<span>(</span><span>\"message\"</span><span>,</span> messageEvent <span>=&gt;</span> <span>{</span>\n  <span>if</span> <span>(</span>messageEvent<span>.</span>data <span>==</span> <span>\"clean up\"</span><span>)</span> <span>{</span>\n    <span spellcheck=\"true\">// loop though the caches\n</span>    <span>for</span> <span>(</span> <span>let</span> key <span>in</span> sw_caches <span>)</span> <span>{</span>\n      <span spellcheck=\"true\">// if the cache has a limit\n</span>      <span>if</span> <span>(</span> sw_caches<span>[</span>key<span>]</span><span>.</span>limit <span>!</span><span>==</span> undefined <span>)</span> <span>{</span>\n        <span spellcheck=\"true\">// trim it to that limit\n</span>        trimCache<span>(</span> sw_caches<span>[</span>key<span>]</span><span>.</span>name<span>,</span> sw_caches<span>[</span>key<span>]</span><span>.</span>limit <span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span></code></pre></figure><p>Here, the Service Worker listens for inbound messages and responds to the ‚Äúclean up‚Äù request by running <code>trimCache()</code> on each of the cache buckets with a defined <code>limit</code>.</p><p>This approach is by no means elegant, but it works. It would be far better to make decisions about purging cached responses based on how frequently each item is accessed and/or how much room it takes up on disk. (Removing cached items based purely on when they were cached isn‚Äôt nearly as useful.) Sadly, we don‚Äôt have that level of detail when it comes to inspecting the caches‚Ä¶yet. I‚Äôm actually working to address this limitation in the Cache API right now.</p><h2 id=\"section13\">Your users always come first<a href=\"#section13\">#section13</a></h2><p>The technologies underlying Progressive Web Apps are continuing to mature, but even if you aren‚Äôt interested in turning your site into a PWA, there‚Äôs so much you can do today to improve your users‚Äô experiences when it comes to media. And, as with every other form of inclusive design, it starts with centering on your users who are most at risk of having an awful experience.</p><p>Draw distinctions between critical, nice-to-have, and superfluous media. Remove the cruft, then optimize the bejeezus out of each remaining asset. Serve your media in multiple formats and sizes, prioritizing the smallest versions first to make the most of high latency and slow connections. If your users say they want to save data, respect that and have a fallback plan in place. Cache wisely and with the utmost respect for your users‚Äô disk space. And, finally, audit your caching strategies regularly‚Äîespecially when it comes to large media files.Follow these guidelines, and every one of your users‚Äîfrom folks rocking a <a href=\"https://www.jio.com/en-in/jiophone2\">JioPhone</a> on a rural mobile network in India to people on a high-end gaming laptop wired to a 10 Gbps fiber line in Silicon Valley‚Äîwill thank you.</p></div></div>","author":"","siteTitle":"A List Apart: The Full Feed","siteHash":"09b09f389b84b264a6ebab120b6208479961d3fe7df4850a75b103b2b9c8a950","entryHash":"f5f87104457e01336f430ea3bf4fbd8469128eb4eb0430dbcbcb8119c7f0e90a","category":"Tech"}