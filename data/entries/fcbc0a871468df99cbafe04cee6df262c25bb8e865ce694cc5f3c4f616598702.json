{"title":"Optimizing Next.js Applications With Nx","link":"https://smashingmagazine.com/2021/10/optimizing-nextjs-applications-nx/","date":1635242400000,"content":"<p>In this article, we will go through how to optimize and build a high-performance Next.js application using <a href=\"https://nx.dev/\">Nx</a> and its rich features. We will go through how to set up an Nx server, how to add a plugin to an existing server, and the concept of a monorepo with a practical visualization.</p>\n<p>If you‚Äôre a developer looking to optimize applications and create reuseable components across applications effectively, this article will show you how to quickly scale your applications, and how to work with Nx. To follow along, you will need basic knowledge of the Next.js framework and TypeScript.</p>\nWhat Is Nx?\n<p><a href=\"https://nx.dev/\">Nx</a> is an open-source build framework that helps you architect, test, and build at any scale ‚Äî integrating seamlessly with modern technologies and libraries, while providing a robust command-line interface (CLI), caching, and dependency management. Nx offers developers advanced CLI tools and plugins for modern frameworks, tests, and tools.</p>\n<p>For this article, we will be focusing on how Nx works with Next.js applications. Nx provides standard tools for testing and styling in your Next.js applications, such as Cypress, Storybook, and styled-components. Nx facilitates a monorepo for your applications, creating a workspace that can hold the source code and libraries of multiple applications, allowing you to share resources between applications.</p>\nWhy Use Nx?\n<p>Nx provides developers with a reasonable amount of functionality out of the box, including boilerplates for end-to-end (E2E) testing of your application, a styling library, and a monorepo.</p>\n<p>Many advantages come with using Nx, and we‚Äôll walk through a few of them in this section.</p>\n<ul>\n<li><strong>Graph-based task execution</strong><br />Nx uses distributed graph-based task execution and computation caching to speed up tasks. The system will schedule tasks and commands using a graph system to determine which node (i.e. application) should execute each task. This handles the execution of applications and optimizes execution time efficiently.</li>\n<li><strong>Testing</strong><br />Nx provides preconfigured test tools for unit testing and E2E tests.</li>\n<li><strong>Caching</strong><br />Nx also stores the cached project graph. This enables it to reanalyze only updated files. Nx keeps track of files changed since the last commit and lets you test, build, and perform actions on only those files; this allows for proper optimization when you‚Äôre working with a large code base.</li>\n<li><strong>Dependency graph</strong><br />The visual dependency graph enables you to inspect how components interact with each other.</li>\n<li><strong>Cloud storage</strong><br />Nx also provides cloud storage and GitHub integration, so that you can share links with team members to review project logs.</li>\n<li><strong>Code sharing</strong><br />Creating a new shared library for every project can be quite taxing. Nx eliminates this complication, freeing you to focus on the core functionality of your app. With Nx, you can share libraries and components across applications. You can even share reusable code between your front-end and back-end applications.</li>\n<li><strong>Support for monorepos</strong><br />Nx provides one workspace for multiple applications. With this setup, one GitHub repository can house the code source for various applications under your workspace.</li>\n</ul>\nNx for Publishable Libraries\n<p>Nx allows you to create publishable libraries. This is essential when you have libraries that you will use outside of the monorepo. In any instance where you are developing organizational UI components with Nx Storybook integration, Nx will create publishable components alongside your stories. The publishable components can compile these components to create a library bundle that you can deploy to an external registry. You would use the <code>--publishable</code> option when generating the library, unlike <code>--buildable</code>, which is used to generate libraries that are used only in the monorepo. Nx does not deploy the publishable libraries automatically; you can invoke the build via a command such as <code>nx build mylib</code> (where <code>mylib</code> is the name of the library), which will then produce an optimized bundle in the <code>dist</code>/<code>mylib</code> folder that can be deployed to an external registry.</p>\n<p>Nx gives you the option to create a new workspace with Next.js as a preset, or to add Next.js to an existing workspace.</p>\n<p>To create a new workspace with Next.js as a preset, you can use the following command:</p>\n<pre><code>npx create-nx-workspace happynrwl \\\n--preset=next \\\n--style=styled-components \\\n--appName=todo</code></pre>\n\n<p>This command will create a new Nx workspace with a Next.js app named ‚Äútodo‚Äù and with <code>styled-components</code> as the styling library.</p>\n<p>Then, we can add the Next.js application to an existing Nx workspace with the following command:</p>\n<pre><code>npx nx g @nrwl/next:app</code></pre>\n\nBuilding a Next.js and Nx Application\n<p>The Nx plugin for Next.js includes tools and executors for running and optimizing a Next.js application. To get started, we need to create a new Nx workspace with <code>next</code> as a preset:</p>\n<pre><code>npx create-nx-workspace happynrwl \\\n--preset=next \\\n--style=styled-components \\\n--appName=todo</code></pre>\n\n<p>The code block above will generate a new Nx workspace and the Next.js application. We will get a prompt to use Nx Cloud. For this tutorial, we will select ‚ÄúNo‚Äù, and then wait for our dependencies to install. Once that‚Äôs done, we should have a file tree similar to this:</p>\n<pre><code>üì¶happynrwl\n ‚î£ üìÇapps\n ‚îÉ ‚î£ üìÇtodo\n ‚îÉ ‚î£ üìÇtodo-e2e\n ‚îÉ ‚îó üìú.gitkeep\n ‚î£ üìÇlibs\n ‚î£ üìÇnode_modules\n ‚î£ üìÇtools\n ‚î£ üìú.editorconfig\n ‚î£ üìú.eslintrc.json\n ‚î£ üìú.gitignore\n ‚î£ üìú.prettierignore\n ‚î£ üìú.prettierrc\n ‚î£ üìúREADME.md\n ‚î£ üìúbabel.config.json\n ‚î£ üìújest.config.js\n ‚î£ üìújest.preset.js\n ‚î£ üìúnx.json\n ‚î£ üìúpackage-lock.json\n ‚î£ üìúpackage.json\n ‚î£ üìútsconfig.base.json\n ‚îó üìúworkspace.json</code></pre>\n\n<p>In the <code>üìÇapps</code> folder, we‚Äôll have our Next.js application ‚Äútodo‚Äù, with the preconfigured E2E test for the to-do app. All is this is auto-generated with the powerful Nx CLI tool.</p>\n<p>To run our app, use the <code>npx nx serve todo</code> command. Once you‚Äôre done serving the app, you should see the screen below:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7e5e7aec-7c22-43c2-88f0-eca07dddd458/image-nx-home.png\" /></p>\n<h3>Building the API</h3>\n<p>At this point, we have set up the workspace. Up next is building the CRUD API that we will use on the Next.js application. To do this, we will be using Express; to demonstrate monorepo support, we will build our server as an application in the workspace. First, we have to install the Express plugin for Nx by running this command:</p>\n<pre><code>npm install --save-dev @nrwl/express</code></pre>\n\n<p>Once that‚Äôs done, we are ready to set up our Express app in the workspace provided. To generate an Express app, run the command below:</p>\n<pre><code>npx nx g @nrwl/express:application --name=todo-api --frontendProject=todo</code></pre>\n\n<p>The command <code>nx g @nrwl/express:application</code> will generate an Express application to which we can pass additional specification parameters; to specify the name of the application, use the <code>--name</code> flag; to indicate the front-end application that will be using the Express app, pass the name of an app in our workspace to <code>--frontendProject</code>. A few other <a href=\"https://nx.dev/latest/node/express/application\">options are available for an Express app</a>. When this is done, we will have an updated file structure in the <code>apps</code> folder with the <code>üìÇtodo-api</code> folder added to it.</p>\n<pre><code>üì¶happynrwl\n ‚î£ üìÇapps\n ‚îÉ ‚î£ üìÇtodo\n ‚îÉ ‚î£ üìÇtodo-api\n ‚îÉ ‚î£ üìÇtodo-e2e\n ‚îÉ ‚îó üìú.gitkeep\n ‚Ä¶</code></pre>\n\n<p>The <code>todo-api</code> folder is an Express boilerplate with a <code>main.ts</code> entry file.</p>\n<pre><code>/**\n * This is not a production server yet!\n * This is only minimal back end to get started.\n */\nimport * as express from 'express';\nimport {v4 as uuidV4} from 'uuid';\n\nconst app = express();\napp.use(express.json()); // used instead of body-parser\n\napp.get('/api', (req, res) =&gt; {\n  res.send({ message: 'Welcome to todo-api!' });\n});\n\nconst port = process.env.port || 3333;\nconst server = app.listen(port, () =&gt; {\n  console.log(`Listening at http://localhost:${port}/api`);\n});\nserver.on('error', console.error);\n</code></pre>\n\n<p>We will be creating our routes inside this app. To get started, we will initialize an array of objects with two key-value pairs, <code>item</code> and <code>id</code>, just under the app declaration.</p>\n<pre><code>/**\n * This is not a production server yet!\n * This is only minimal back end to get started.\n */\nimport * as express from 'express';\nimport {v4 as uuidV4} from 'uuid';\n\nconst app = express();\napp.use(express.json()); // used instead of body-parser\n\nlet todoArray: Array&lt;{ item: string; id: string }&gt; = [\n  { item: 'default todo', id: uuidV4() },\n];\n‚Ä¶</code></pre>\n\n<p>Next up, we will set up the route to fetch all to-do lists under <code>app.get()</code>:</p>\n<pre><code>‚Ä¶\napp.get('/api', (req, res) =&gt; {\n  res.status(200).json({\n    data: todoArray,\n  });\n});\n‚Ä¶</code></pre>\n\n<p>The code block above will return the current value of <code>todoArray</code>. Subsequently, we will have routes for creating, updating, and removing to-do items from the array.</p>\n<pre><code>‚Ä¶\n\napp.post('/api', (req, res) =&gt; {\n  const item: string = req.body.item;\n  // Increment ID of item based on the ID of the last item in the array.\n  let id: string = uuidV4();\n  // Add the new object to the array\n  todoArray.push({ item, id });\n  res.status(200).json({\n    message: 'item added successfully',\n  });\n});\napp.patch('/api', (req, res) =&gt; {\n  // Value of the updated item\n  const updatedItem: string = req.body.updatedItem;\n  // ID of the position to update\n  const id: string = req.body.id;\n  // Find index of the ID\n  const arrayIndex = todoArray.findIndex((obj) =&gt; obj.id === id);\n\n  // Update item that matches the index\n  todoArray[arrayIndex].item = updatedItem\n\n  res.status(200).json({\n    message: 'item updated successfully',\n  });\n});\n\napp.delete('/api', (req, res) =&gt; {\n  // ID of the position to remove\n  const id: string = req.body.id;\n  // Update array and remove the object that matches the ID\n  todoArray = todoArray.filter((val) =&gt; val.id !== id);\n  res.status(200).json({\n    message: 'item removed successfully',\n  });\n});\n\n‚Ä¶</code></pre>\n\n<p>To create a new to-do item, all we need is the value of the new item as a string. We‚Äôll generate an ID by incrementing the ID of the last element in the array on the server. To update an existing item, we would pass in the new value for the item and the ID of the item object to be updated; on the server, we would loop through each item with the <code>forEach</code> method, and update the item in the place where the ID matches the ID sent with the request. Finally, to remove an item from the array, we‚Äôd send the item‚Äôs ID to be removed with the request; then, we filter through the array, and return a new array of all items not matching the ID sent with the request, assigning the new array to the <code>todoArray</code> variable.</p>\n<p><strong>Note:</strong> If you look in the Next.js application folder, you should see a <code>proxy.conf.json</code> file with the configuration below:</p>\n<pre><code>{\n  \"/api\": {\n    \"target\": \"http://localhost:3333\",\n    \"secure\": false\n  }\n}</code></pre>\n\n<p>This creates a proxy, allowing all API calls to routes matching <code>/api</code> to target the <code>todo-api</code> server.</p>\n<h3>Generating Next.js Pages With Nx</h3>\n<p>In our Next.js application, we will generate a new page, <code>home</code>, and an item component. Nx provides a CLI tool for us to easily create a page:</p>\n<pre><code>npx nx g @nrwl/next:page home</code></pre>\n\n<p>Upon running this command, we will get a prompt to select the styling library that we want to use for the page; for this article, we will select <code>styled-components</code>. Voil√†! Our page is created. To create a component, run <code>npx nx g @nrwl/next:component todo-item</code>; this will create a <code>component</code> folder with the <code>todo-item</code> component.</p>\n<h3>API Consumption in Next.js Application</h3>\n<p>In each to-do item, we will have two buttons, to edit and delete the to-do item. The asynchronous functions performing these actions are passed as props from the home page.</p>\n<pre><code>‚Ä¶\nexport interface TodoItemProps {\n  updateItem(id: string, updatedItem: string): Promise&lt;void&gt;;\n  deleteItem(id: string): Promise&lt;void&gt;;\n  fetchItems(): Promise&lt;any&gt;;\n  item: string;\n  id: string;\n}\nexport const FlexWrapper = styled.div`\n  width: 100%;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  border-bottom: 1px solid #ccc;\n  padding-bottom: 10px;\n  margin-top: 20px;\n  @media all and (max-width: 470px) {\n    flex-direction: column;\n    input {\n      width: 100%;\n    }\n    button {\n      width: 100%;\n    }\n  }\n`;\n\nexport function TodoItem(props: TodoItemProps) {\n  const [isEditingItem, setIsEditingItem] = useState&lt;boolean&gt;(false);\n  const [item, setNewItem] = useState&lt;string | null&gt;(null);\n\n  return (\n    &lt;FlexWrapper&gt;\n      &lt;Input\n        disabled={!isEditingItem}\n        defaultValue={props.item}\n        isEditing={isEditingItem}\n        onChange={({ target }) =&gt; setNewItem(target.value)}\n      /&gt;\n      {!isEditingItem &amp;&amp; &lt;Button\n        onClick={() =&gt; setIsEditingItem(true)}\n      &gt;\n        Edit\n      &lt;/Button&gt;}\n      {isEditingItem &amp;&amp; &lt;Button onClick={async () =&gt; {\n         await props.updateItem(props.id, item);\n         //fetch updated items\n         await props.fetchItems();\n         setIsEditingItem(false)\n         }}&gt;\n        Update\n      &lt;/Button&gt;}\n      &lt;Button\n        danger\n        onClick={async () =&gt; {\n          await props.deleteItem(props.id);\n\n          //fetch updated items\n          await await props.fetchItems();\n        }}\n      &gt;\n        Delete\n      &lt;/Button&gt;\n    &lt;/FlexWrapper&gt;\n  );\n}</code></pre>\n\n<p>For the updating functionality, we have an input that is disabled when the <code>isEditingItem</code> state is <code>false</code>. Once the ‚ÄúEdit‚Äù button is clicked, it toggles the <code>isEditingItem</code> state to <code>true</code> and displays the ‚ÄúUpdate‚Äù button. Here, the input component is enabled, and the user can enter a new value; when the ‚ÄúUpdate‚Äù button is clicked, it calls the <code>updateItem</code> function with the parameters passed in, and it toggles <code>isEditingItem</code> back to <code>false</code>.</p>\n<p>In the <code>home</code> page component, we have the asynchronous functions performing the CRUD operation.</p>\n<pre><code> ‚Ä¶\n  const [items, setItems] = useState&lt;Array&lt;{ item: string; id: string }&gt;&gt;([]);\n  const [newItem, setNewItem] = useState&lt;string&gt;('');\n  const fetchItems = async () =&gt; {\n    try {\n      const data = await fetch('/api/fetch');\n      const res = await data.json();\n      setItems(res.data);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  const createItem = async (item: string) =&gt; {\n    try {\n      const data = await fetch('/api', {\n        method: 'POST',\n        body: JSON.stringify({ item }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  const deleteItem = async (id: string) =&gt; {\n    try {\n      const data = await fetch('/api', {\n        method: 'DELETE',\n        body: JSON.stringify({ id }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n      const res = await data.json();\n      alert(res.message);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  const updateItem = async (id: string, updatedItem: string) =&gt; {\n    try {\n      const data = await fetch('/api', {\n        method: 'PATCH',\n        body: JSON.stringify({ id, updatedItem }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n      const res = await data.json();\n      alert(res.message);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  useEffect(() =&gt; {\n    fetchItems();\n  }, []);\n‚Ä¶</code></pre>\n\n<p>In the code block above, we have <code>fetchItems</code>, which returns <code>todoArray</code> from the server. Then, we have the <code>createItem</code> function, which takes a string; the parameter is the value of the new to-do item. The <code>updateItem</code> function takes two parameters, the ID of the item to be updated and the <code>updatedItem</code> value. And the <code>deleteItem</code> function removes the item matching the ID that is passed in.</p>\n<p>To render the to-do item, we map through the <code>items</code> state:</p>\n<pre><code> ‚Ä¶\nreturn (\n    &lt;StyledHome&gt;\n      &lt;h1&gt;Welcome to Home!&lt;/h1&gt;\n      &lt;TodoWrapper&gt;\n         {items.length &gt; 0 &amp;&amp;\n          items.map((val) =&gt; (\n            &lt;TodoItem\n              key={val.id}\n              item={val.item}\n              id={val.id}\n              deleteItem={deleteItem}\n              updateItem={updateItem}\n              fetchItems={fetchItems}\n            /&gt;\n          ))}\n      &lt;/TodoWrapper&gt;\n      &lt;form\n        onSubmit={async(e) =&gt; {\n          e.preventDefault();\n          await createItem(newItem);\n          //Clean up new item\n          setNewItem('');\n          await fetchItems();\n        }}\n      &gt;\n        &lt;FlexWrapper&gt;\n          &lt;Input\n            value={newItem}\n            onChange={({ target }) =&gt; setNewItem(target.value)}\n            placeholder=\"Add new item‚Ä¶\"\n          /&gt;\n          &lt;Button success type=\"submit\"&gt;\n            Add +\n          &lt;/Button&gt;\n        &lt;/FlexWrapper&gt;\n      &lt;/form&gt;\n    &lt;/StyledHome&gt;\n  );\n‚Ä¶</code></pre>\n\n<p>Our server and front end are now set up. We can serve the API application by running <code>npx nx serve todo-api</code>, and for the Next.js application, we run <code>npx nx serve todo</code>. Click the ‚ÄúContinue‚Äù button, and you will see a page with the default to-do item displayed.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/363121db-4f9d-453c-bb27-392631228fdd/image-app-home.png\" /></p>\n<p>We now have a working Next.js and Express application working together in one workspace.</p>\n<p>Nx has another CLI tool that allows us to view the dependency graph of our application in our terminal run. Run <code>npx nx dep-graph</code>, and we should see a screen similar to the image below, depicting the dependency graph of our application.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cd3a32f3-b23f-4fa3-b3ed-233bb3c6f6b7/image-app-architecture.png\" /></p>\n<h3>Other CLI Commands for Nx</h3>\n<ul>\n<li><code>nx list</code><br />Lists the currently installed Nx plugins.</li>\n<li><code>nx migrate latest</code><br />Updates the packages in <code>package.json</code> to the latest version.</li>\n<li><code>nx affected</code><br />Performs the action on only the affected or modified apps.</li>\n<li><code>nx run-many --target serve --projects todo-api,todo</code><br />Runs the target command across all projects listed.</li>\n</ul>\nConclusion\n<p>As a general overview of Nx, this article has covered what Nx offers and how it makes work easier for us. We also walked through setting up a Next.js application in an Nx workspace, adding an Express plugin to an existing workspace, and using the monorepo feature to house more than one application in our workspace.</p>\n<p>You will find the complete source code in the <a href=\"https://github.com/MelvinManni/NX_Next_Express\">GitHub repository</a>. For additional information about Nx, check out the <a href=\"https://nx.dev/\">documentation</a> or the Nx <a href=\"https://nx.dev/latest/react/guides/nextjs\">documentation for Next.js</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"fcbc0a871468df99cbafe04cee6df262c25bb8e865ce694cc5f3c4f616598702","category":"Tech"}