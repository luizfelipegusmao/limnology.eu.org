{"title":"Useful React APIs For Building Flexible Components With TypeScript","link":"https://smashingmagazine.com/2021/10/react-apis-building-flexible-components-typescript/","date":1634040000000,"content":"<p>Have you ever used <code>React.createElement</code> directly? What about <code>React.cloneElement</code>? React is more than just transforming your JSX into HTML. Much more, and to help you level up your knowledge of lesser-known (but very useful) APIs the React library ships with. We‚Äôre going to go over a few of them and some of their use cases that can drastically enhance your components' integration and usefulness. </p>\n<p>In this article, we‚Äôll go over a few useful React APIs that are not as commonly known but extremely useful for web developers. Readers should be experienced with React and JSX syntax, Typescript knowledge is helpful but not necessary. Readers will walk away with everything they need to know in order to greatly enhance React components when using them in React applications.</p>\n<code>React.cloneElement</code>\n<p>Most developers may never have heard of <code>cloneElement</code> or ever used it. It was relatively recently introduced to replace the <a href=\"https://reactjs.org/docs/react-api.html#cloneelement\">now deprecated <code>cloneWithProps</code> function</a>. <code>cloneElement</code> clones an element, it also lets you merge new props with the existing element, modifying them or overriding them as you see fit. This opens up extremely powerful options for building world-class APIs for functional components. Take a look at the signature.</p>\n<pre><code>function cloneElement( element, props?, ...children)</code></pre>\n\n<p>Here‚Äôs the condensed Typescript version:</p>\n<pre><code>function cloneElement( \n   element: ReactElement, \n   props?: HTMLAttributes, \n   ...children: ReactNode[]): ReactElement</code></pre>\n\n<p>You can take an element, modify it, even override its children, and then return it as a new element. Take a look at the following example. Let‚Äôs say we want to create a <strong>TabBar</strong> component of links. That might look something like this.</p>\n<pre><code>export interface ITabbarProps {\n  links: {title: string, url: string}[]\n}\n\nexport default function Tabbar(props: ITabbarProps) {\n return (\n   &lt;&gt;\n     {props.links.map((e, i) =&gt;\n       &lt;a key={i} href={e.url}&gt;{e.title}&lt;/a&gt;\n     )}\n   &lt;/&gt;\n )\n}</code></pre>\n\n<p>The TabBar is a list of links, but we need a way to define two pieces of data, the title of the link, and the URL. So we‚Äôll want a data structure passed in with this information. So our developer would make our component like so.</p>\n<pre><code>function App() {\n return (\n   &lt;Tabbar links={[\n     {title: 'First', url: '/first'},\n     {title: 'Second', url: '/second'}]\n   } /&gt;\n )\n}</code></pre>\n\n<p>This is great, but what if the user wants to render <code>button</code> elements instead of <code>a</code> elements? Well, we could add another property that tells the component what type of element to render. </p>\n<p>But you can see how this will quickly get unwieldy, we would need to support more and more properties to handle various use cases and edge cases for maximum flexibility. </p>\n<p>Here‚Äôs a better way, using <code>React.cloneElement</code>.</p>\n<p>We‚Äôll start by changing our interface to reference the <code>ReactNode</code> type. This is a generic type that encompasses anything React can render, typically JSX Elements but also can be strings and even <code>null</code>. This is useful for designating you to want to accept React components or JSX as arguments inline.</p>\n<pre><code>export interface ITabbarProps {\n links: ReactNode[]\n}</code></pre>\n\n<p>Now we‚Äôre asking the user to give us some React Elements, and we‚Äôll render them how we want. </p>\n<pre><code>function Tabbar(props: ITabbarProps) {\n return (\n   &lt;&gt;\n     {props.links.map((e, i) =&gt;\n       e // simply return the element itself\n     )}\n   &lt;/&gt;\n )\n}</code></pre>\n\n<p>This is perfectly valid and would render our elements. But we‚Äôre forgetting a couple of things. For one, <code>key</code>! We want to add keys so React can render our lists efficiently. We also want to alter our elements to make necessary transformations so they fit into our styling, such as <code>className</code>, and so on.</p>\n<p>We can do these with <code>React.cloneElement</code>, and another function <code>React.isValidElement</code> for checking the argument conforms to what we‚Äôre expecting!</p>\n<code>React.isValidElement</code>\n<p>This function returns <code>true</code> if an element is a valid React Element and React can render it. Here‚Äôs an example of modifying the elements from the previous example.</p>\n<pre><code>function Tabbar(props: ITabbarProps) {\n return (\n   &lt;&gt;\n     {props.links.map((e, i) =&gt;\n       isValidElement(e) &amp;&amp; cloneElement(e, {key: `${i}`, className: 'bold'})\n     )}\n   &lt;/&gt;\n )\n}</code></pre>\n\n<p>Here we‚Äôre adding a key prop to each element we‚Äôre passing in and making every link bold at the same time! We can now accept arbitrary React Elements as props like so:</p>\n<pre><code>function App() {\n return (\n   &lt;Tabbar links={[\n     &lt;a href='/first'&gt;First&lt;/a&gt;,\n     &lt;button type='button'&gt;Second&lt;/button&gt;\n   ]} /&gt;\n )\n}</code></pre>\n\n\n<p>We can override any of the props set on an element, and easily accept various kinds of elements making our component much more flexible and easy to use.</p>\n<p>The advantage here is if we wanted to set a custom <code>onClick</code> handler to our button, we could do so. Accepting React elements themselves as arguments is a powerful way to give flexibility to your component design.</p>\n<code>useState</code> Setter Function\n<p>Use Hooks! The <code>useState</code> hook is extremely useful and a fantastic API for quickly building state into your components like so: </p>\n<pre><code>const [myValue, setMyValue] = useState()</code></pre>\n\n<p>Due to the JavaScript runtime, it can have some hiccups. Remember closures?</p>\n<p>In certain situations, a variable might not be the correct value because of the context it is in, such as in for-loops commonly or asynchronous events. This is because of lexical scoping. When a new function is created the lexical scope is preserved. Because there is no new function, the lexical scope of <code>newVal</code> is not preserved, and so the value is actually dereferenced by the time it is used. </p>\n<pre><code>setTimeout(() =&gt; {\n setMyValue(newVal) // this will not work\n}, 1000)</code></pre>\n\n<p>What you‚Äôll need to do is utilize the setter as a function. By creating a new function the variables reference is preserved in lexical scope and the currentVal is passed in by the React useState Hook itself.</p>\n<pre><code>setTimeout(() =&gt; {\n setMyValue((currentVal) =&gt; {\n   return newVal\n })\n}, 1000)</code></pre>\n\n<p>This will ensure that your value is updated correctly because the setter function is called in the correct context. What React does here is call your function in the correct context for a React state update to occur. This can also be used in other situations where it‚Äôs helpful to act on the current value, React calls your function with the first argument as the current value.</p>\n<p><strong>Note</strong>: <em>For additional reading on the topic of async and closures, I recommend reading ‚Äú<a href=\"https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates\"><code>useState</code> Lazy Initialization And Function Updates</a>‚Äù by Kent C. Dodds.</em></p>\nJSX Inline Functions\n<p>Here‚Äôs a Codepen demo of a JSX inline function:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/QWgQQKR\">Hello World in React</a> by <a href=\"https://codepen.io/gvkhna\">Gaurav Khanna</a>.</p>\n<p>Not exactly a React API per-say.</p>\n<p>JSX does support inline functions and it can be really useful for declaring simple logic with variables inline, as long as it returns a JSX Element.</p>\n<p>Here‚Äôs an example:</p>\n<pre><code>function App() {\n  return (\n    &lt;&gt;\n     {(() =&gt; {\n       const darkMode = isDarkMode()\n       if (darkMode) {\n         return (\n           &lt;div className='dark-mode'&gt;&lt;/div&gt;\n         )\n       } else {\n         return (\n           &lt;div className='light-mode'&gt;&lt;/div&gt;\n         ) // we can declare JSX anywhere!\n       }\n\n     })()} // don't forget to call the function!\n    &lt;/&gt;\n  )\n}</code></pre>\n\n<p>Here we‚Äôre declaring code inside of JSX, we can run arbitrary code and all we have to do is return a JSX function to be rendered. </p>\n<p>We can make it conditional, or simply perform some logic. Take note of the parentheses surrounding the inline function. Also particularly here where we are calling this function, we could even pass an argument into this function from the surrounding context if we wanted to!</p>\n<pre><code>})()}</code></pre>\n\n<p>This can be useful in situations where you want to act on a collection data structure in a more complex way than a standard <code>.map</code> allows for inside of a JSX element.</p>\n<pre><code>function App() {\n  return (\n    &lt;&gt;\n      {(() =&gt; {\n        let str = ''\n        for (let i = 0; i &lt; 10; i++) {\n          str += i\n        }\n        return (&lt;p&gt;{str}&lt;/p&gt;) \n      })()}\n    &lt;/&gt;\n  )\n}</code></pre>\n\n<p>Here we can run some code to loop through a set of numbers and then display them inline. If you use a static site generator such as Gatsby, this step would be pre-computed as well.</p>\n<code>component extends type</code>\n<p>Immensely useful for creating autocomplete-friendly components, this feature allows you to create components that extend existing <code>HTMLElements</code> or other components. Mostly useful for correctly typing an elements interface in Typescript but the actual application is the same for JavaScript.</p>\n<p>Here‚Äôs a simple example, let‚Äôs say we want to override one or two properties of a <code>button</code> element, but still give developers the option to add other properties to the button. Such as setting <code>type='button'</code> or <code>type='submit'</code>. We obviously don‚Äôt want to recreate the entire button element, we just want to extend its existing properties, and maybe add one more prop. </p>\n<pre><code>import React, { ButtonHTMLAttributes } from 'react'</code></pre>\n\n<p>First we import React and the <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/1349b640d4d07f40aa7c1c6931f18e3fbf667f3a/types/react/index.d.ts#L1957\"><code>ButtonHTMLAttributes</code></a> class, a type that encompasses the props of a <code>HTMLButtonElement</code>. You can read the source code for this type of interface here: </p>\n<p>And you can see the React team has reimplemented all of the web‚Äôs APIs in TypeScript so can be type-checked.</p>\n<p>Next, we declare our interface like so, adding our <code>status</code> property.</p>\n<pre><code>interface ButtonProps extends ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {\n status?: 'primary' | 'info' | 'danger'\n}</code></pre>\n\n<p>And finally, we do a couple of things. We use ES6 destructuring to pull out the props that we care about (<code>status</code>, and <code>children</code>), and declare any other properties as <code>rest</code>. And in our JSX output, we return a button element, with ES6 structuring to add any additional properties to this element. </p>\n<pre><code>function Button(props: ButtonProps) {\n const { status, children, ...rest } = props // rest has any other props\n return (\n   &lt;button\n     className={`${status}`}\n     {...rest} // we pass the rest of the props back into the element\n   &gt;\n     {children}\n   &lt;/button&gt;\n )\n}</code></pre>\n\n<p>So now a developer can add a <code>type</code> prop or any other prop that a button would typically have. We‚Äôve given an additional prop that we‚Äôve utilized in the <code>className</code> to set the style of the button.</p>\n<p>Here‚Äôs the entire example:</p>\n<pre><code>import React, { ButtonHTMLAttributes } from 'react'\n\nexport interface ButtonProps extends ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {\n status?: 'primary' | 'info' | 'danger'\n}\n\nexport default function Button(props: ButtonProps) {\n const { status, children, ...rest } = props\n return (\n   &lt;button\n     className={`${status}`}\n     {...rest}\n   &gt;\n     {children}\n   &lt;/button&gt;\n )\n}</code></pre>\n\n<p>This makes for a great way of creating reusable internal components that conform to your style guidelines without rebuilding entire HTML elements! You can simply override entire props such as setting the <code>className</code> based on the status or allow for additional class names to be passed in as well.</p>\n<pre><code>import React, { ButtonHTMLAttributes } from 'react'\n\nexport interface ButtonProps extends ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {\n status?: 'primary' | 'info' | 'danger'\n}\n\nexport default function Button(props: ButtonProps) {\n const { status, children, className, ...rest } = props\n return (\n   &lt;button\n     className={`${status || ''} ${className || ''}`}\n     {...rest}\n   &gt;\n     {children}\n   &lt;/button&gt;\n )\n}</code></pre>\n\n<p>Here we take the prop <code>className</code> passed to our Button element, and insert it back in, with a safety check in the case of the prop being <code>undefined</code>. </p>\nConclusion\n<p>React is an extremely powerful library, and there‚Äôs a good reason why it has quickly gained popularity. It gives you a great tool-set to build performant and easy-to-maintain web apps. It‚Äôs extremely flexible and yet very strict at the same time, which can be incredibly useful if you know how to use it. These are just a few APIs that are noteworthy and are largely overlooked. Give them a try in your next project!</p>\n<p>For further reading about the latest React APIs, hooks, I would recommend reading <a href=\"https://usehooks.com/\">useHooks(üê†)</a>. The <a href=\"https://github.com/typescript-cheatsheets/react\">Typescript Cheatsheet</a> also has some great information for React and Typescript Hooks.</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"77a382d109bdc1abf84788e8cd20154bbe77b37bd515c5f142b829bdb8b8cf3d","category":"Tech"}