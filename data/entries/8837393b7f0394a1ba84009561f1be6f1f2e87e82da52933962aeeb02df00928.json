{"title":"React Children And Iteration Methods","link":"https://smashingmagazine.com/2021/08/react-children-iteration-methods/","date":1628073000000,"content":"<p>The most obvious and common prop that developers work with within React is the <code>children</code> prop. In the majority of cases, there is no need to understand how the <code>children</code> prop looks like. But in some cases, we want to inspect the <code>children</code> prop to maybe wrap each child in another element/component or to reorder or slice them. In those cases inspecting how the <code>children</code> prop looks like becomes essential.</p>\n<p>In this article, we‚Äôll look at a React utility <code>React.Children.toArray</code> which lets us prepare the <code>children</code> prop for inspection and iteration, some of its shortcomings and how to overcome them ‚Äî through a small open-source package, to keep our React code function the way it is deterministically supposed to behave, keeping performance intact. If you know the basics of React and have at least an idea about what the <code>children</code> prop in React is, this article is for you.</p>\n<p>While working with React, most of the time we do not touch the <code>children</code> prop any more than using it in React components directly.</p>\n<pre><code>function Parent({ children }) {\n  return &lt;div className=\"mt-10\"&gt;{children}&lt;/div&gt;;\n}</code></pre>\n\n<p>But sometimes we have to iterate over the <code>children</code> prop so that we can enhance or change the children without having the user of the components explicitly do it themselves. One common use case is to pass the iteration index-related information to child components of a parent like so:</p>\n<pre><code>import { Children, cloneElement } from \"react\";\n\nfunction Breadcrumbs({ children }) {\n  const arrayChildren = Children.toArray(children);\n\n  return (\n    &lt;ul\n      style={{\n        listStyle: \"none\",\n        display: \"flex\",\n      }}\n    &gt;\n      {Children.map(arrayChildren, (child, index) =&gt; {\n        const isLast = index === arrayChildren.length - 1;\n\n        if (! isLast &amp;&amp; ! child.props.link ) {\n          throw new Error(\n            `BreadcrumbItem child no. ${index + 1}\n            should be passed a 'link' prop`\n          )\n        } \n\n        return (\n          &lt;&gt;\n            {child.props.link ? (\n              &lt;a\n                href={child.props.link}\n                style={{\n                  display: \"inline-block\",\n                  textDecoration: \"none\",\n                }}\n              &gt;\n                &lt;div style={{ marginRight: \"5px\" }}&gt;\n                  {cloneElement(child, {\n                    isLast,\n                  })}\n                &lt;/div&gt;\n              &lt;/a&gt;\n            ) : (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;\n                {cloneElement(child, {\n                  isLast,\n                })}\n              &lt;/div&gt;\n            )}\n            {!isLast &amp;&amp; (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;\n                &gt;\n              &lt;/div&gt;\n            )}\n          &lt;/&gt;\n        );\n      })}\n    &lt;/ul&gt;\n  );\n}\n\nfunction BreadcrumbItem({ isLast, children }) {\n  return (\n    &lt;li\n      style={{\n        color: isLast ? \"black\" : \"blue\",\n      }}\n    &gt;\n      {children}\n    &lt;/li&gt;\n  );\n}\n\nexport default function App() {\n  return (\n    &lt;Breadcrumbs&gt;\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/\"\n      &gt;\n        Goibibo\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/hotels/\"\n      &gt;\n        Hotels\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItem&gt;\n       A Fancy Hotel Name\n      &lt;/BreadcrumbItem&gt;\n    &lt;/Breadcrumbs&gt;\n  );\n}\n</code></pre>\n\n<p>Take a look at the <a href=\"https://codesandbox.io/embed/sm-article-21-lt6le?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. Here we‚Äôre doing the following:</p>\n<ol>\n<li>We are using the <code>React.Children.toArray</code> method to ensure that the <code>children</code> prop is always an array. If we do not do that, doing <code>children.length</code> might blow because the <code>children</code>  prop can be an object, an array, or even a function. Also, if we try to use the array <code>.map</code> method on <code>children</code> directly it might blow up.</li>\n<li>In the parent <code>Breadcrumbs</code> component we are iterating over its children by using the utility method <code>React.Children.map</code>.</li>\n<li>Because we have access to <code>index</code> inside the iterator function (second argument of callback function of <code>React.Children.map</code>) we are able to detect if the child is last-child or not.</li>\n<li>If it is the last child we clone the element and pass in the <code>isLast</code> prop to it so that the child can style itself based on it.</li>\n<li>If it is not the last child, we ensure that all those children which aren‚Äôt the last child have a <code>link</code> prop on them by throwing an error if they don‚Äôt. We clone the element as we did in step 4. and pass the <code>isLast</code> prop as we did before, but we also additionally wrap this cloned element in an anchor tag. </li>\n</ol>\n<p>The user of <code>Breadcrumbs</code> and <code>BreadcrumbItem</code> doesn‚Äôt have to worry about which children should have links and how they should be styled. Inside the <code>Breadcrumbs</code> component, it automatically gets handled.</p>\n<p>This pattern of <em>implicitly</em> passing in props and/or having <code>state</code> in the parent and passing the state and state changers down to the children as props is called the <a href=\"https://kentcdodds.com/blog/compound-components-with-react-hooks/\">compound component pattern</a>. You might be familiar with this pattern from React Router‚Äôs <code>Switch</code> component, which takes <code>Route</code> components as its children:</p>\n<pre><code>// example from react router docs\n// https://reactrouter.com/web/api/Switch\n\nimport { Route, Switch } from \"react-router\";\n\nlet routes = (\n  &lt;Switch&gt;\n    &lt;Route exact path=\"/\"&gt;\n      &lt;Home /&gt;\n    &lt;/Route&gt;\n    &lt;Route path=\"/about\"&gt;\n      &lt;About /&gt;\n    &lt;/Route&gt;\n    &lt;Route path=\"/:user\"&gt;\n      &lt;User /&gt;\n    &lt;/Route&gt;\n    &lt;Route&gt;\n      &lt;NoMatch /&gt;\n    &lt;/Route&gt;\n  &lt;/Switch&gt;\n);</code></pre>\n\n<p>Now that we have established that there are needs where we have to iterate over <code>children</code> prop sometimes, and having used two of the children utility methods <code>React.Children.map</code> and <code>React.Children.toArray</code>, let‚Äôs refresh our memory about one of them: <code>React.Children.toArray</code>.</p>\n<code>React.Children.toArray</code>\n<p>Let‚Äôs start by seeing with an example what this method does and where it might be useful.</p>\n<pre><code>import { Children } from 'react'\n\nfunction Debugger({children}) {\n  // let‚Äôs log some things\n  console.log(children);\n  console.log(\n    Children.toArray(children)\n  )\n  return children;\n}\n\nconst fruits = [\n  {name: \"apple\", id: 1},\n  {name: \"orange\", id: 2},\n  {name: \"mango\", id: 3}\n]\n\nexport default function App() {\n  return (\n    &lt;Debugger&gt;\n        &lt;a\n          href=\"https://css-tricks.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          CSS Tricks\n        &lt;/a&gt;\n\n        &lt;a\n          href=\"https://smashingmagazine.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          Smashing Magazine\n        &lt;/a&gt;\n\n        {\n          fruits.map(fruit =&gt; {\n            return (\n              &lt;div key={fruit.id} style={{margin: '10px'}}&gt;\n                {fruit.name}\n              &lt;/div&gt;\n            )\n          })\n        }\n    &lt;/Debugger&gt;\n  )\n}</code></pre>\n\n<p>Take a look at the <a href=\"https://codesandbox.io/embed/sm-article-22-hhuws?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. We have a <code>Debugger</code> component, which does nothing much in terms of rendering ‚Äî it just returns <code>children</code> as is. But it does log two values: <code>children</code> and <code>React.Children.toArray(children)</code>.</p>\n<p>If you open up the console, you‚Äôd be able to see the difference.</p>\n<ul>\n<li>The first statement which logs <code>children</code> prop, shows the following as its value‚Äôs data structure: </li>\n</ul>\n<pre><code>[\n  Object1, ----&gt; first anchor tag\n  Object2, ----&gt; second anchor tag\n  [\n    Object3, ----&gt; first fruit\n    Object4, ----&gt; second fruit\n    Object5] ----&gt; third fruit\n  ]\n]</code></pre>\n\n<ul>\n<li>The second statement which logs <code>React.Children.toArray(children)</code> logs:</li>\n</ul>\n<pre><code>[\n  Object1, ----&gt; first anchor tag\n  Object2, ----&gt; second anchor tag\n  Object3, ----&gt; first fruit\n  Object4, ----&gt; second fruit\n  Object5, ----&gt; third fruit\n]</code></pre>\n\n<p>Let‚Äôs read the method‚Äôs documentation in React docs to make sense of what is happening.</p>\n<blockquote>\n<p><code>React.Children.toArray</code> returns the <code>children</code> opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice <code>children</code> before passing it down.</p>\n</blockquote>\n<p>Let‚Äôs break that down:</p>\n<ol>\n<li>Returns the <code>children</code> opaque data structure as a flat array.</li>\n<li>With keys assigned to each child.</li>\n</ol>\n<p>The first point says that that <code>children</code> (which is an opaque data structure, meaning it can be an object, array, or a function, as described earlier) is converted to a flat array. Just like we saw in the example above. Additionally, this <a href=\"https://github.com/facebook/react/issues/6889#issuecomment-221858162\">GitHub issue comment</a> also explains its behavior:</p>\n<blockquote>\n<p>It (<code>React.Children.toArray</code>) does not pull children out of elements and flatten them, that wouldn‚Äôt really make any sense. It flattens nested arrays and objects, i.e. so that <code>[['a', 'b'],['c', ['d']]]</code> becomes something similar to <code>['a', 'b', 'c', 'd']</code>.</p>\n</blockquote>\n<pre><code>React.Children.toArray(\n  [\n    [\"a\", \"b\"],\n    [\"c\", [\"d\"]]\n  ]\n).length === 4;</code></pre>\n\n<p>Let‚Äôs see what the second point (‚ÄòWith keys assigned to each child.‚Äô) says, by expanding one child each from the previous logs of the example.</p>\n<h3>Expanded Child From  <code>console.log(children)</code></h3>\n<pre><code>{\n  $$typeof: Symbol(react.element),\n  key: null,\n  props: {\n    href: \"https://smashingmagazine.com\",\n    children: \"Smashing Magazine\",\n    style: {padding: \"0 10px\"}\n  },\n  ref: null,\n  type: \"a\",\n  // ‚Ä¶ other properties\n}</code></pre>\n\n\n\n<h3>Expanded Child From <code>console.log(React.Children.toArray(children))</code></h3>\n<pre><code>{\n  $$typeof: Symbol(react.element),\n  key: \".0\",\n  props: {\n    href: \"https://smashingmagazine.com\",\n    children: \"Smashing Magazine\",\n    style: {padding: \"0 10px\"}\n  },\n  ref: null,\n  type: \"a\",\n  // ‚Ä¶ other properties\n}</code></pre>\n\n<p>As you can see, besides flattening the <code>children</code> prop into a flat array, it also adds unique keys to each of its children. From the React docs:</p>\n<blockquote><code>React.Children.toArray()</code> changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, <code>toArray</code> prefixes each key in the returned array so that each element‚Äôs key is scoped to the input array containing it.</blockquote>\n\n<p>Because the <code>.toArray</code> method might change the order and place of <code>children</code>, it has to make sure that it maintains unique keys for each of them for <a href=\"https://reactjs.org/docs/reconciliation.html#recursing-on-children\">reconciliation and rendering optimization</a>.</p>\n<p>Let‚Äôs give a little bit more attention to <em><code>so that each element‚Äôs key is scoped to the input array containing it.</code></em>, by looking at the keys of each element of the second array (corresponding to <code>console.log(React.Children.toArray(children))</code>).</p>\n<pre><code>import { Children } from 'react'\n\nfunction Debugger({children}) {\n  // let‚Äôs log some things\n  console.log(children);\n  console.log(\n    Children.map(Children.toArray(children), child =&gt; {\n      return child.key\n    }).join('\\n')\n  )\n  return children;\n}\n\nconst fruits = [\n  {name: \"apple\", id: 1},\n  {name: \"orange\", id: 2},\n  {name: \"mango\", id: 3}\n]\n\nexport default function App() {\n  return (\n    &lt;Debugger&gt;\n        &lt;a\n          href=\"https://css-tricks.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          CSS Tricks\n        &lt;/a&gt;\n        &lt;a\n          href=\"https://smashingmagazine.com/\"\n          style={{padding: '0 10px'}}\n        &gt;\n          Smashing Magazine\n        &lt;/a&gt;\n        {\n          fruits.map(fruit =&gt; {\n            return (\n              &lt;div key={fruit.id} style={{margin: '10px'}}&gt;\n                {fruit.name}\n              &lt;/div&gt;\n            )\n          })\n        }\n    &lt;/Debugger&gt;\n  )\n}</code></pre>\n\n<pre><code>.0  ----&gt; first link\n.1  ----&gt; second link\n.2:0 ----&gt; first fruit\n.2:1 ----&gt; second fruit\n.2:2 ----&gt; third fruit</code></pre>\n\n<p>As you can see that the fruits, which were originally a nested array inside the original <code>children</code> array, have keys that are prefixed with <code>.2</code>. The <code>.2</code> corresponds to the fact that they were a part of an array. The suffix, namely <code>:0</code> ,<code>:1</code>, <code>:2</code> are corresponding to the React elements‚Äô (fruits) default keys. By default, React uses the index as the key, if no key is specified for the elements of a list.</p>\n<p>So suppose you had three level of nesting inside <code>children</code> array, like so:</p>\n<pre><code>import { Children } from 'react'\n\nfunction Debugger({children}) {\n  const retVal = Children.toArray(children)\n  console.log(\n    Children.map(retVal, child =&gt; {\n      return child.key\n    }).join('\\n')\n  )\n  return retVal\n}\n\nexport default function App() {\n  const arrayOfReactElements = [\n    &lt;div key=\"1\"&gt;First&lt;/div&gt;,\n    [\n      &lt;div key=\"2\"&gt;Second&lt;/div&gt;,\n      [\n        &lt;div key=\"3\"&gt;Third&lt;/div&gt;\n      ]\n    ]\n  ];\n  return (\n    &lt;Debugger&gt;\n      {arrayOfReactElements}\n    &lt;/Debugger&gt;\n  )\n}</code></pre>\n\n<p>The keys will look like</p>\n<pre><code>.$1\n.1:$2\n.1:1:$3</code></pre>\n\n<p>Check the <a href=\"https://codesandbox.io/embed/sm-article-23-5fwrd?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. The <code>$1</code>, <code>$2</code>, <code>$3</code> suffixes are because of the original keys put on the React elements in an array, otherwise React complains of lack of keys üòâ .</p>\n<p>From whatever we‚Äôve read so far we can come to two use cases for <code>React.Children.toArray</code>.</p>\n<ol>\n<li><p>If there‚Äôs an absolute need that <code>children</code> should always be an array, you can use <code>React.Children.toArray(children)</code> instead. It‚Äôll work perfectly even when <code>children</code> is an object or a function too.</p>\n</li>\n<li><p>If you have to sort, filter, or slice <code>children</code> prop you can rely on <code>React.Children.toArray</code> to always preserve unique keys of all the children.</p>\n</li>\n</ol>\n<p><strong>There‚Äôs a problem with <code>React.Children.toArray</code></strong> ü§î. Let‚Äôs look at this piece of code to understand what the problem is:</p>\n<pre><code>import { Children } from 'react'\n\nfunction List({children}) {\n  return (\n    &lt;ul&gt;\n      {\n        Children.toArray(\n          children\n        ).map((child, index) =&gt; {\n          return (\n            &lt;li\n              key={child.key}\n            &gt;\n              {child}\n            &lt;/li&gt;\n          )\n        })\n      }\n    &lt;/ul&gt;\n  )\n}\n\nexport default function App() {\n  return (\n    &lt;List&gt;\n      &lt;a\n        href=\"https://css-tricks.com\"\n        style={{padding: '0 10px'}}\n      &gt;\n        Google\n      &lt;/a&gt;\n      &lt;&gt;\n        &lt;a\n          href=\"https://smashingmagazine.com\"\n          style={{padding: '0 10px'}}\n        &gt;\n          Smashing Magazine\n        &lt;/a&gt;\n        &lt;a\n          href=\"https://arihantverma.com\"\n          style={{padding: '0 10px'}}\n        &gt;\n          {\"Arihant‚Äôs Website\"}\n        &lt;/a&gt;\n      &lt;/&gt;\n    &lt;/List&gt;\n  )\n}</code></pre>\n\n<p>Check the <a href=\"https://codesandbox.io/embed/sm-article-24-dqld3?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. If you see what gets rendered for the children of the fragment, you‚Äôll see that both of the links get rendered inside one <code>li</code> tag! üò±</p>\n<p>This is because <a href=\"https://github.com/facebook/react/issues/6889\"><code>React.Children.toArray</code></a> <a href=\"https://github.com/facebook/react/issues/6889\">doesn‚Äôt traverse into fragments</a>. So what can we do about it? Fortunately, nothing üòÖ . We already have an open-sourced package called <a href=\"https://github.com/grrowl/react-keyed-flatten-children\"><code>react-keyed-flatten-children</code></a>. It‚Äôs a small function that does its magic. </p>\n<p>Let‚Äôs see what it does. In pseudo-code (these points are linked in the actual code below), it does this:</p>\n<ol>\n<li>It is a function that takes <code>children</code> as its only necessary argument.</li>\n<li>Iterates over <code>React.Children.toArray(children)</code> and gathers children in an accumulator array.</li>\n<li>While iterating, if a child node is a string or a number, it pushes the value as is in the accumulator array.</li>\n<li>If the child node is a valid React element, it clones it, gives it the appropriate key, and pushes it to the accumulator array.</li>\n<li>If the child node is a fragment, then the function calls itself with fragment‚Äôs children as its argument (this is how it <em>traverses through a fragment</em>) and pushes the result of calling itself in the accumulator array.</li>\n<li>While doing all this it keeps the track of the depth of traversal (of fragments), so that the children inside fragments would have correct keys, the same way as keys work with nested arrays, as we saw earlier above.</li>\n</ol>\n<pre><code>import {\n  Children,\n  isValidElement,\n  cloneElement\n} from \"react\";\n\nimport { isFragment } from \"react-is\";\n\nimport type {\n  ReactNode,\n  ReactChild,\n} from 'react'\n\n/*************** 1. ***************/\nexport default function flattenChildren(\n  // only needed argument\n  children: ReactNode,\n  // only used for debugging\n  depth: number = 0,\n  // is not required, start with default = []\n  keys: (string | number)[] = [] \n): ReactChild[] {\n  /*************** 2. ***************/\n  return Children.toArray(children).reduce(\n    (acc: ReactChild[], node, nodeIndex) =&gt; {\n      if (isFragment(node)) {\n        /*************** 5. ***************/\n        acc.push.apply(\n          acc,\n          flattenChildren(\n            node.props.children,\n            depth + 1,\n            /*************** 6. ***************/\n            keys.concat(node.key || nodeIndex)\n          )\n        );\n      } else {\n        /*************** 4. ***************/\n        if (isValidElement(node)) {\n          acc.push(\n            cloneElement(node, {\n              /*************** 6. ***************/\n              key: keys.concat(String(node.key)).join('.')\n            })\n          );\n        } else if (\n          /*************** 3. ***************/\n          typeof node === \"string\"\n          || typeof node === \"number\"\n        ) {\n          acc.push(node);\n        }\n      }\n      return acc; \n    },\n    /*************** Acculumator Array ***************/\n    []\n  );\n}</code></pre>\n\n<p>Let‚Äôs retry our previous example to use this function and see for ourselves that it fixes our problem.</p>\n<pre><code>import flattenChildren from 'react-keyed-flatten-children'\nimport { Fragment } from 'react'\n\nfunction List({children}) {\n  return (\n    &lt;ul&gt;\n      {\n        flattenChildren(\n          children\n        ).map((child, index) =&gt; {\n          return &lt;li key={child.key}&gt;{child}&lt;/li&gt;\n        })\n      }\n    &lt;/ul&gt;\n  )\n}\nexport default function App() {\n  return (\n    &lt;List&gt;\n      &lt;a\n        href=\"https://css-tricks.com\"\n        style={{padding: '0 10px'}}\n      &gt;\n        Google\n      &lt;/a&gt;\n      &lt;Fragment&gt;\n        &lt;a\n          href=\"https://smashingmagazine.com\"\n          style={{padding: '0 10px'}}&gt;\n          Smashing Magazine\n        &lt;/a&gt;\n\n        &lt;a\n          href=\"https://arihantverma.com\"\n          style={{padding: '0 10px'}}\n        &gt;\n          {\"Arihant‚Äôs Website\"}\n        &lt;/a&gt;\n      &lt;/Fragment&gt;\n    &lt;/List&gt;\n  )\n}</code></pre>\n\n<p>And <a href=\"https://codesandbox.io/embed/sm-article-25-b76gn?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">here‚Äôs the final result</a> (on Codesandbox)! <em>Woooheeee!</em> It works.</p>\n<p>As an add-on, if you are new to testing ‚Äî like I am at the point of this writing ‚Äî you might be interested in <a href=\"https://github.com/grrowl/react-keyed-flatten-children/blob/master/index.spec.tsx\">7 tests</a> written for this utility function. It‚Äôll be fun to read the tests to deduce the functionality of the function.</p>\nThe Long Term Problem With <code>Children</code> Utilities\n<blockquote>‚Äú<code>React.Children</code> is a leaky abstraction, and is in maintenance mode.‚Äù<br /><br />‚Äî <a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-431247764\">Dan Abramov</a></blockquote>\n\n<p>The problem with using <code>Children</code> methods to change <code>children</code> behavior is that they only work for one level of nesting of components. If we wrap one of our <code>children</code> in another component, we lose composability. Let‚Äôs see what I mean by that, by picking up the first example that we saw ‚Äî the breadcrumbs.</p>\n<pre><code>import { Children, cloneElement } from \"react\";\n\nfunction Breadcrumbs({ children }) {\n  return (\n    &lt;ul\n      style={{\n        listStyle: \"none\",\n        display: \"flex\",\n      }}\n    &gt;\n      {Children.map(children, (child, index) =&gt; {\n        const isLast = index === children.length - 1;\n        // if (! isLast &amp;&amp; ! child.props.link ) {\n        //   throw new Error(`\n        //     BreadcrumbItem child no.\n        //     ${index + 1} should be passed a 'link' prop`\n        //   )\n        // } \n        return (\n          &lt;&gt;\n            {child.props.link ? (\n              &lt;a\n                href={child.props.link}\n                style={{\n                  display: \"inline-block\",\n                  textDecoration: \"none\",\n                }}\n              &gt;\n                &lt;div style={{ marginRight: \"5px\" }}&gt;\n                  {cloneElement(child, {\n                    isLast,\n                  })}\n                &lt;/div&gt;\n              &lt;/a&gt;\n            ) : (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;\n                {cloneElement(child, {\n                  isLast,\n                })}\n              &lt;/div&gt;\n            )}\n            {!isLast &amp;&amp; (\n              &lt;div style={{ marginRight: \"5px\" }}&gt;&gt;&lt;/div&gt;\n            )}\n          &lt;/&gt;\n        );\n      })}\n    &lt;/ul&gt;\n  );\n}\n\nfunction BreadcrumbItem({ isLast, children }) {\n  return (\n    &lt;li\n      style={{\n        color: isLast ? \"black\" : \"blue\",\n      }}\n    &gt;\n      {children}\n    &lt;/li&gt;\n  );\n\n}\nconst BreadcrumbItemCreator = () =&gt;\n  &lt;BreadcrumbItem\n    link=\"https://smashingmagazine.com\"\n  &gt;\n    Smashing Magazine\n  &lt;/BreadcrumbItem&gt;\n\nexport default function App() {\n  return (\n    &lt;Breadcrumbs&gt;\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/\"\n      &gt;\n        Goibibo\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItem\n        link=\"https://goibibo.com/hotels/\"\n      &gt;\n        Goibibo Hotels\n      &lt;/BreadcrumbItem&gt;\n\n      &lt;BreadcrumbItemCreator /&gt;\n\n      &lt;BreadcrumbItem&gt;\n        A Fancy Hotel Name\n      &lt;/BreadcrumbItem&gt;\n    &lt;/Breadcrumbs&gt;\n  );\n}</code></pre>\n\n<p>Take a look at the <a href=\"https://codesandbox.io/embed/sm-article-26-7067h?fontsize=14&amp;hidenavigation=1&amp;theme=dark\">Codesandbox demo</a>. Although our new component <code>&lt;BreadcrumbItemCreator /&gt;</code> rendered, our <code>Breadcrumb</code> component doesn‚Äôt have any way to extract out the <code>link</code> prop from it, because of which, it doesn‚Äôt render as link.</p>\n<p>To fix this problem React team had come with ‚Äî now defunct ‚Äî experimental API called <a href=\"https://www.npmjs.com/package/react-call-return\">react-call-return</a>.</p>\n<p><a href=\"https://www.youtube.com/watch?v=60MfXWyQhRE\">Ryan Florence‚Äôs Video</a> explains this problem in detail, and how <code>react-call-return</code> fixed it. Since the package was never published in any version of React, <a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-584402735\">there are plans to take inspiration from it and make something production-ready.</a></p>\nConclusion\n<p>To conclude, we learned about:</p>\n<ol>\n<li>The <code>React.Children</code> utility methods. We saw two of them: <code>React.Children.map</code> to see how to use it to make compound components, and <code>React.Children.toArray</code> in depth.</li>\n<li>We saw how <code>React.Children.toArray</code> converts opaque <code>children</code> prop ‚Äî which could be either object, array or function ‚Äî into a flat array, so that one could operate over it in required manner ‚Äî sort, filter, splice, etc‚Ä¶</li>\n<li>We learned that <code>React.Children.toArray</code> doesn‚Äôt traverse through React Fragments.</li>\n<li>We learned about an open-source package called <code>react-keyed-flatten-children</code> and understood how it solves the problem.</li>\n<li>We saw that <code>Children</code> utilities are in maintenance mode <a href=\"https://twitter.com/0xca0a/status/1371016849664704513\">because they do not compose well</a>.</li>\n</ol>\n<p>You might also be interested in reading how to use other <code>Children</code> methods to do everything you can do with <code>children</code> in Max Stoiber‚Äôs blog post <a href=\"https://mxstbr.blog/2017/02/react-children-deepdive/\">React Children Deep Dive</a>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://kentcdodds.com/blog/compound-components-with-react-hooks/\">Compound components with react hooks</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/6889#issuecomment-221858162\">React.Children.toArray array flattening github issue explanation</a></li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html#recursing-on-children\">React reconciliation: Recursing on children</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/6889\"><code>React.Children.toArray</code> doesn‚Äôt traverse into fragments</a></li>\n<li><a href=\"https://github.com/grrowl/react-keyed-flatten-children\"><code>react-keyed-flatten-children</code></a></li>\n<li><a href=\"https://github.com/grrowl/react-keyed-flatten-children/blob/master/index.spec.tsx\"><code>react-keyed-flatten-children</code></a> <a href=\"https://github.com/grrowl/react-keyed-flatten-children/blob/master/index.spec.tsx\">tests</a></li>\n<li><a href=\"https://www.npmjs.com/package/react-call-return\">react-call-return</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=60MfXWyQhRE\">Ryan Florence‚Äôs Video explaining react-call-return</a></li>\n<li><a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-584402735\">React team‚Äôs plan to replace <code>Children</code> utilities with something more composable</a></li>\n<li><a href=\"https://mxstbr.blog/2017/02/react-children-deepdive/\">Max Stoiber‚Äôs <code>React Children</code> Deep Dive</a></li>\n<li><a href=\"https://github.com/reactjs/rfcs/pull/61#issuecomment-431247764\"><code>React.Children</code> is a leaky abstraction, and is in maintenance mode</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"8837393b7f0394a1ba84009561f1be6f1f2e87e82da52933962aeeb02df00928","category":"Tech"}