{"title":"Discovering Primitive Objects In JavaScript (Part 1)","link":"https://smashingmagazine.com/2023/02/discovering-primitive-objects-javascript-part1/","date":1676030400000,"content":"<p>It seems natural to use strings to distinguish things. It‚Äôs very likely that in your codebase, there are objects with <code>name</code>, <code>id</code>, or <code>label</code> properties that are used to determine if an object is the one you‚Äôre looking for.</p>\n<pre><code>if (element.label === \"title\") {\n    make_bold(element);\n}\n</code></pre>\n\n<p>At a certain point, your project grows (in size, importance, popularity, or all at once). It needs more strings as there are more things to distinguish from each other. The strings grow longer, as does the cost of typos or, say, your label naming convention changes. Now you have to find all the instances of those strings and replace them. Consequently, a commit for that change becomes much bigger than it should be. Which makes you look better in the eyes of the clueless. Simultaneously it makes your life miserable since it‚Äôs much harder now to find the cause of regression in your git history.</p>\n<p>Strings are bad for identification. You have to consider uniqueness and typos; your editor or IDE won‚Äôt check if it‚Äôs the string you meant. It‚Äôs bad. I hear someone saying, ‚ÄúJust put them in a variable, duh.‚Äù That‚Äôs a good suggestion, and it removes some of my concerns. But look at John Smith:</p>\n<pre><code>const john_smith_a_person = \"John Smith\";\nconst john_smith_a_company = \"John Smith\";\n\n// Do they have the same name?\njohn_smith_a_person === john_smith_a_company; // true\n\n// Are they the same thing?\njohn_smith_a_person === john_smith_a_company; // true\n</code></pre>\n\n<p>John happens to share the name with a company. What if I say to you I have a better solution? The one that removes all the concerns and adds more value ‚Äî allows you to achieve more. What would you say? Well, I won‚Äôt rewrite the article just because your answer doesn‚Äôt fit my narrative. The answer is objects. You use objects themselves to figure out if an object is the one you‚Äôre looking for.</p>\n<pre><code>// Do they have a same name?\njohn_smith_a_person.name === john_smith_a_company.name; // true\n\n// Are they the same thing?\njohn_smith_a_person === john_smith_a_company; // false\n</code></pre>\n\n<p>It makes the intent clearer. Let me give you a better example. Say you have labels in your app. They are localized, so the label string is determined by the localization library you‚Äôre using and your team‚Äôs translation process. You keep your labels in a module where you have them all neatly organized and curated. Once you need to do something special for certain labels, you can compare it directly with the one you‚Äôve got.</p>\n<pre><code>import React from \"react\";\nimport labels from \"./labels.js\";\n\nconst render_label(label) =&gt; (\n    &lt;Label\n        className={label === labels.title ? \"bold\" : \"plain\"}\n        icon={label.icon}\n        text={label.text}\n    /&gt;\n)\n\nfunction TableOfContents({ items }) {\n    return (\n        &lt;ul className=\"my-menu\"&gt;\n            {items.map(render_label(item.label)}\n        &lt;/ul&gt;\n    );\n}\n</code></pre>\n\n<p>See how much more I can do with objects? In the <code>labels</code> module, I‚Äôve set aside a label <code>title</code>, which in this case should be rendered bold. Plus, being an object, my label can hold a localization string (imaginatively called <code>text</code>) and an icon. It‚Äôs all neatly organized in advance, which keeps my UI logic clean.</p>\n<p>But it‚Äôs just a part of the picture. I know we use objects all over the place, and it‚Äôs nothing new to group things in them. But I bet you don‚Äôt use them exactly like that. I rarely see two objects being compared like that because you never know what‚Äôs in there or where it came from. Objects are created and changed all the time. It is more likely for them to be compared by the values of their properties than the objects themselves. And the reason for that is that objects aren‚Äôt suitable for that kind of use. They are too capable. To allow that use case and many others, we have to, on the one hand, reduce some capabilities of objects and, on the other, implement some more. And in the end, we‚Äôll get what I call <strong>Primitive Objects</strong>. Th... a solution to al... some problems.</p>\n<p>In the first part of the series, I want to cover some aspects of JavaScript that help bring objects closer to primitive values, which in return would allow us to benefit from common language features that aren‚Äôt usually associated with an object, like comparisons and arithmetic operators. In the following part, we‚Äôll look closely into practical examples and tools to work with such objects. Now let‚Äôs see what objects are like in JavaScript.</p>\nProperties Of Primitive Values We Need\n<p>First, let‚Äôs define our goal. Let‚Äôs draw a picture of where we would like to be afterward. What properties of primitive values do we want our objects to have?</p>\n<ul>\n<li><strong>Immutability</strong><br />Primitive values are read-only. We want our objects not to be editable by anybody after their creation. Recall the example before. What use of a label do we have if some code out of our control has changed the text or icon of it? Once the object is defined, it should be set in stone.</li>\n<li><strong>Work with operators.</strong><br />Expressions with certain operators return their appropriate type. Arithmetic operators give numbers back. Comparisons give booleans.</li>\n<li><strong>Have literal syntax.</strong><br />Literals for primitives give you the exact value, or rather an object representing the value. Such objects get created once for each value. Each time you have <code>\"hello\"</code> in your code, you get the same object.</li>\n<li><strong>Have types.</strong><br />The <code>typeof</code> operator tells you what you‚Äôre dealing with (except for <code>null</code>). We don‚Äôt always know which kind of object we get. So before we poke its properties, it would be nice to know what we‚Äôre dealing with.</li>\n</ul>\n<p>I listed them by immediate usefulness. And as luck would have it, they are also ordered by easiest to get. In this article, I‚Äôll cover the first one and a part of the second one. We‚Äôll see how to make objects immutable. We also will define their representation in primitive values, which allows us to use some operators on them. Moving from objects to primitive values is easy, as primitive values are objects themselves ‚Äî sort of.</p>\nIt‚Äôs Objects All the Way Down, Even If It Kinda Isn‚Äôt\n<p>I remember my confusion when I first saw <code>{} === {}; // false</code>. What is this language that cannot even tell apart two equal things? It felt so ridiculous and amusing. It was much later that I learnt that there are much worse parts in JavaScript, after which I stopped laughing while watching <a href=\"https://www.destroyallsoftware.com/talks/wat\">wat talk</a>.</p>\n<p>An object is one of the fundamental things in JavaScript. You might have heard that in JavaScript, everything is an object. That‚Äôs quite true. Apart from some bottom values, all the primitives are objects. While technically, it is more nuanced, from the perspective of our code, it is true. In fact, it‚Äôs true enough that believing everything is an object might be a useful mental model. But let‚Äôs first try to understand what is happening with that object-to-object comparison that was so amusing to younger me.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer\">Object literal</a> syntax is used for creating new objects. It allows us to declare and initiate an object in a single expression.</p>\n<pre><code>// Instead of this.\nconst my_object = new Object();\nmy_object.first_property = \"First property\";\nmy_object.nth_property = \"Next property\";\n\n// You can do this.\nconst my_object = {\n    first_property: \"First property\",\n    nth_property: \"Next property\"\n};\n</code></pre>\n\n<p>Much cleaner, right? But now I think the lack of object initialization line is what got me confused about those two empty object equality expressions. It seemed to show the language‚Äôs struggle to recognize apparent equality. But what actually happens in that expression is this:</p>\n<pre><code>new Object() === new Object(); // false\n</code></pre>\n\n<p>Now it‚Äôs obvious they aren‚Äôt equal. You‚Äôre comparing two distinct objects you‚Äôve just created. To expect contrary is the same as expecting <code>5 === 3</code> to return <code>true</code>. In both cases, they are different things.</p>\n<p>Let‚Äôs do a sanity check. Would two variables referring to the same object be considered equal?</p>\n<pre><code>const my_object = {};\nconst other_thing = my_object;\nmy_object === other_thing; // true\n</code></pre>\n\n<p>In this case, only the first line has an expression that creates an object. On the second line, we make the <code>other_thing</code> variable refer to a just-created object. Two variables are now referring to the same object. Comparing them is just like comparing two equal numbers, isn‚Äôt it?</p>\n<p>Why is this significant? Because it gives us a way to check if a variable refers to an object we‚Äôre looking for. And if we think about it in the context of ‚Äúeverything is an object,‚Äù that‚Äôs how numbers and strings work. When you compare two variables holding strings, the engine doesn‚Äôt have to check if each character in those strings is the same. It‚Äôs enough to compare if the variables refer to the same object. That is thanks to the most significant difference between regular objects and primitive values ‚Äî immutability.</p>\nHow To Bring Regular Objects Closer To Primitive Values\n<p>In JavaScript, Primitive values are immutable. You cannot change a single character in a string as well as you cannot make a number five to become six. If you use <code>const</code> to initialize a variable and put a primitive value in it, it‚Äôll always stay the same. No one could change the value; it‚Äôs immutable. No one could reassign the variable; it was created with <code>const</code>.</p>\n<p>Let‚Äôs look closely at how numbers work. You can get six out of five by incrementing it by one, but it doesn‚Äôt change anything about five.</p>\n<pre><code>const five = 5;\nconst six = 5 + 1;\nfive === 5; // true\n</code></pre>\n\n<p>Some might say that using <code>let</code> would change that. But look, it cannot change five:</p>\n<pre><code>const five = 5;\nlet result = 5;\nresult++;\nresult === 6; // true\nfive === 5; // true\n</code></pre>\n\n<p>A five is still a five. That is because <code>++</code> is just a shorthand for <code>+= 1</code>. See the equals sign? What happened was I <em>assigned</em> a new value to the <code>result</code> variable, the value that I got from the <code>result + 1</code> expression (which is what <code>+= 1</code> is a shorthand for). The <code>const</code> keyword prevents reassignment to a variable. In the example above, that‚Äôs what gives me a way to know that <code>five</code> always refers to a <code>5</code> object.</p>\n<p>We might assume that the only way primitive values are <em>changed</em> in JavaScript is through the assignment, which means what we‚Äôre actually changing is what a variable refers to. So it‚Äôs variables that are changing, not values. Not primitive ones, at least. But how it works with objects instead?</p>\n<p>After initializing an object, you can change its properties: delete them, add new ones, and reassign old ones. We are all familiar with doing that. But apart from that, it behaves the same as primitive values. In fact, if you get accustomed to a model where objects and primitive values are the same things, you‚Äôll look differently at all sorts of problems in JavaScript.</p>\n<p>You probably stumbled upon a question about how variables are passed to a function. People ask whether variables are passed by value or by reference. A common answer is <strong>primitive values are passed by value</strong> while objects are passed by reference. But with the mental model I‚Äôm forcing on you here, you might already know what I will say about that. Before that, let me show you how the question doesn‚Äôt make much sense in JavaScript. I will also reveal to you a sleight of hand that many articles and tutorials use.</p>\n<p>When you pass variables as parameters of a function call, they get assigned to the function‚Äôs arguments. Arguments are local variables to a function‚Äôs scope and have no connection back to the original variables, which makes sense. If you pass an expression to a function, you have to put the result of it somewhere, don‚Äôt you?</p>\n<p>Look at the following two functions. They do the same thing, pass a value through, but one is defined with a single parameter, the other with none. The second one demonstrates what is happening with the parameter we passed in.</p>\n<pre><code>function single(arg) {\n    return arg;\n}\n\nfunction none() {\n\n    // The first parameter is assigned to a variable `arg`.\n    // Notice the `let`; it will be significant later.\n    let arg = arguments[0];\n\n    return arg;\n}\n\nsingle(\"hi\"); // \"hi\"\nnone(5);      // 5\n</code></pre>\n\n<p>You see that they both work the same. Keeping in mind how function arguments work, let‚Äôs try changing some values. We‚Äôll have a function that changes its only argument and returns it. I also will create some variables that I‚Äôll pass to the function one by one. Try to predict what would be printed in the console. (Answer is in the second sentence of the next paragraph.)</p>\n<pre><code>function reassign(arg) {\n    arg = \"OMG\";\n}\n\nconst unreassignable = \"What\";\nlet reassignable = \"is\";\nlet non_primitive = { val: \"happening\" };\n\nreassign(unreassignable);\nreassign(reassignable);\nreassign(non_primitive);\n\nconsole.log(unreassignable, reassignable, non_primitive.val, \"üò±\");\n</code></pre>\n\n<p>Did your guess has any ‚ÄúOMG‚Äù in it? It shouldn‚Äôt have, as the console will show ‚ÄúWhat is happening üò±.‚Äù No matter what gets passed to a function in JavaScript, reassigning changes only the argument variable. So, neither <code>const</code> nor <code>let</code> change anything here because the function doesn‚Äôt get the variable itself. But what happens if we try changing the properties of an argument?</p>\n<p>I created another function that tries to change the <code>val</code> property of its argument. See if you can guess the message in the console this time.</p>\n<pre><code>function change_val_prop(arg) {\n    try {\n        arg.val = \"OMG\";\n    } catch (ignore) {}\n}\n\nconst a_string = \"What\";\nconst a_number = 15;\nconst non_primitive = { val: \"happening\" };\nconst non_primitive_read_only = Object.freeze({ my_string: \"here\" });\n\nchange_val_prop(a_string);\nchange_val_prop(a_number);\nchange_val_prop(non_primitive);\nchange_val_prop(non_primitive_read_only);\n\nconsole.log(\n    a_string.val,\n    a_number.val,\n    non_primitive.val,\n    non_primitive_read_only.val,\n    \"üò±\"\n);\n</code></pre>\n\n<p>Is there any ‚ÄúOMG‚Äù in your guess now? Great, the message is ‚Äúundefined undefined OMG undefined üò±.‚Äù The only time the function could change the property is with a common object. What does it tell us? Is there any difference between how primitive values are passed and how objects are? Is it that passing frozen object suddenly changes it to pass-by-value? I think it‚Äôs more useful to treat them as equals.</p>\n<p>Now about that sleight of hand I mentioned. Practically all the resources do that thing where they say that primitives and objects are passed differently, then immediately follow it with an example where they treat them differently. Look at <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#description\">function description in MDN</a>. By the time of this writing, it described it like this (emphasis mine):</p>\n<blockquote>Arguments may be passed by value (in the case of primitive values) or by reference (in the case of objects). This means that if a function <strong>reassigns</strong> a primitive type parameter, the value won‚Äôt change outside the function. In the case of an object type parameter, if <strong>its properties are mutated</strong>, the change will impact outside of the function.</blockquote>\n\n<p>I just showed you the reassigning wouldn‚Äôt change the object either. You cannot change primitives‚Äô properties because they are read-only, which is also the case for frozen objects. And most of the examples you‚Äôll find do the same thing. They first state the difference between two values, then demonstrate it using different methods for each value.</p>\n<p>I‚Äôm not trying to criticize, don‚Äôt get me wrong. It probably was done because it explains JavaScript quirks in a more familiar way. Just be aware that sometimes an explanation gives you a model of thinking about a problem. But the model is never completely true to the nature of a problem.</p>\n<p>Looking at this issue from the perspective of primitives being just like frozen objects helps you to recognize what actually happens. Alternative tutorials become illogical. And now, having discovered this notion of a primitive object that no one could change, let us make them more friendly for the rest of your program.</p>\nConverting\n<p>Primitive values stand on their own; any program knows how to handle them. Objects could be anything. And even if you call them primitive, it‚Äôs not enough for them to suddenly become first-class citizens. To achieve some of that, we need to do some work.</p>\n<p>You can define a way to convert objects into primitive values such as strings or numbers. For example, let‚Äôs create an object representing a rating from zero to five. We need to be able to work with numeric representation for comparison and sorting. We also need to be able to output it in text.</p>\n<p>There are certain methods that you could define to describe your object‚Äôs representation. Remember <code>[object Object]</code>? It‚Äôs what you get when you try to turn your object into a string:</p>\n<pre><code>String({}); // \"[object Object]\"\n</code></pre>\n\n<p>Let‚Äôs change that.</p>\n<h3>String Representation</h3>\n<p>That output comes from the default <code>toString</code> method defined in the Object prototype. But you could overwrite it by defining it on your own object.</p>\n<pre><code>String({ toString: () =&gt; \"hello there\" }); // \"hello there\"\n</code></pre>\n\n<p>That‚Äôs what we will use for our rating objects. To make it convenient, let‚Äôs create a function that initializes and freezes such objects. It will also check if the value is within the zero to five range and return <code>undefined</code> otherwise.</p>\n<pre><code>function new_rating(value) {\n    const max = 5;\n\n    // That symbol forces textual representation (who needs emoji anyway üôÑ).\n    const text_only = \"\\ufe0e\";\n\n    const star = \"‚≠ë\" + text_only;\n    const no_star = \"‚≠ê\" + text_only;\n\n    if (\n        !Number.isSafeInteger(value) ||\n        (value &lt; 0 || value &gt; max)\n    ) {\n        return undefined;\n    }\n\n    return Object.freeze({\n        value,\n        toString: () =&gt; star.repeat(value) + no_star.repeat(max - value)\n    });\n}\n</code></pre>\n\n<p>Now let‚Äôs rate something. There is a pen I like. It‚Äôs pretty great, and I‚Äôd give it five stars.</p>\n<pre><code>const ratings = new WeakMap();\nratings.set(jetstream_pen, new_rating(5));\n</code></pre>\n\n<p>This <code>WeakMap</code> for ratings is how you could assign properties to objects without actually changing them. Now, whenever we want to have a rating, we can convert both of our objects to strings.</p>\n<pre><code>if (ratings.has(jetstream_pen)) {\n    console.log(`${jetstream_pen} ${ratings.get(jetstream_pen)}`);\n    // \"Uni-Ball Jetstream 0.5 ‚≠ëÔ∏é‚≠ëÔ∏é‚≠ëÔ∏é‚≠ëÔ∏é‚≠ëÔ∏é\"\n}\n</code></pre>\n\n<p>Wrapping both objects in string template literal is what I relied on here to trigger the <code>toString</code> method. Otherwise, you could just call the <code>String</code> function on them, as I did at the beginning of this section.</p>\n<h3>For Numberphiles</h3>\n<p>For numbers, there‚Äôs the <code>valueOf</code> method, which is called whenever there‚Äôs an attempt to convert to number comparisons or math operators (except for <code>+</code>). Let‚Äôs add it to our <code>new_rating</code> function:</p>\n<pre><code>function new_rating(value) {\n    // ...\n\n    return Object.freeze({\n        value,\n        valueOf: () =&gt; value,\n        toString: () =&gt; star.repeat(value) + no_star.repeat(max - value)\n    });\n}\n</code></pre>\n\n<p>Now it might seem redundant to return the <code>value</code> property directly. But remember that no one but us knows that it‚Äôs there. Returning it from <code>valueOf</code> is a universal way to get a numeric representation.</p>\n<p>Let‚Äôs say we have our pen object again. And let‚Äôs say the rating is now its property (just to simplify the example). We can now filter out items with less than four stars:</p>\n<pre><code>articles.filter((item) =&gt; item.rating &gt; 3);\n// [ { name: \"Uni-Ball Jetstream 0.5\", ... } ]\n</code></pre>\n\n<p>Similarly, we can sort items by rating. We can do that using the Arrays‚Äô <code>sort</code> method. You probably already have your favorite little sorting function that you‚Äôd like to use, like this one:</p>\n<pre><code>function sorter(first, second) {\n    return second.rating - first.rating;\n}\n\nconst sorted_by_rating = array_of.sort(sorter);\n</code></pre>\n\n<p>Now, <code>sorted_by_rating</code> holds an array of the very best items.</p>\nConclusion\n<p>I rarely looked at objects as something that could extend what could be expressed in JavaScript. With primitive objects, that‚Äôs what I‚Äôm trying to explore. There are still things we cannot add, like new operators or literal syntax, but still, with primitive objects, we could define new types of values.</p>\n<p>In this first part of the <em>Primitive Objects</em> series, I tried to give an overview of how to make objects resemble some primitives properties. You freeze them to make them read-only. You also can define a representation in primitives, either number or string, to make it work with arithmetic operators or output them in text.</p>\n<p>In the next parts coming up next week, I aim to give more examples of usage and comparison with other approaches I‚Äôve encountered. You will see how to make it easier to create primitive objects and turn them into structures.</p>\n<p>In this series, I‚Äôm trying to touch on <strong>JavaScript features that can be relied on</strong>. Even if not all of it makes sense, I hope that by looking at some of the examples I gave here, you‚Äôll learn something useful that would make working with JavaScript less brittle without unnecessarily turning to additional tools.</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"10ea21582270ab2bf18fcd8527eeebd35781bc23acb619dcf88aef001de794a4","category":"Tech"}