{"title":"Creating An Outside Focus And Click Handler React Component","link":"https://smashingmagazine.com/2021/03/outside-focus-click-handler-react-component/","date":1614769200000,"content":"<p>Oftentimes we need to detect when a click has happened outside of an element or when the focus has shifted outside of it. Some of the evident examples for this use case are fly-out menus, dropdowns, tooltips and popovers. Let‚Äôs start the process of making this detection functionality.</p>\n<h3>The DOM Way To Detect Outside Click</h3>\n<p>If you were asked to write code <em>to detect if a click happened inside a DOM node or outside of it</em>, what would you do? Chances are you‚Äôd use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\"><code>Node.contains</code></a> DOM API. Here‚Äôs how MDN explains it:</p>\n<blockquote><p>The <code>Node.contains()</code> method returns a <code>Boolean</code> value indicating whether a node is a descendant of a given node, i.e. the node itself, one of its direct children (<code>childNodes</code>), one of the children‚Äôs direct children, and so on.</p></blockquote>\n\n<p>Let‚Äôs quickly test it out. Let‚Äôs make an element we want to detect outside click for. I‚Äôve conveniently given it a <code>click-text</code> class.</p>\n<pre><code>&lt;section&gt;\n  &lt;div class=\"click-text\"&gt;\n    click inside and outside me\n  &lt;/div&gt;\n&lt;/section&gt;</code></pre>\n\n<pre><code>const concernedElement = document.querySelector(\".click-text\");\n\ndocument.addEventListener(\"mousedown\", (event) =&gt; {\n  if (concernedElement.contains(event.target)) {\n    console.log(\"Clicked Inside\");\n  } else {\n    console.log(\"Clicked Outside / Elsewhere\");\n  }\n});</code></pre>\n\n<p>We did the following things:</p>\n<ol>\n<li>Selected the HTML element with the class <code>click-text</code>.</li>\n<li>Put a mouse down event listener on <code>document</code> and set an event handler callback function.</li>\n<li>In the callback function, we are checking if our concerned element ‚Äî for which we have to detect outside click ‚Äî contains the element (including itself) which triggered the <code>mousedown</code> event (<code>event.target</code>). </li>\n</ol>\n<p>If the element which triggered the mouse down event is either our concerned element or any element which is inside the concerned element, it means we have clicked inside our concerned element.</p>\n<p>Let‚Äôs click inside and outside of the element in the Codesandbox below, and check the console.</p>\n\n\n<h3>Wrapping DOM Hierarchy Based Detection Logic In A React Component</h3>\n<p>Great! So far we saw how to use DOM‚Äôs <code>Node.contains</code> API to detect click outside of an element. We can wrap that logic in a React component. We could name our new React component  <code>OutsideClickHandler</code>. Our <code>OutsideClickHandler</code> component will work like this:</p>\n<div>\n<pre><code>&lt;OutsideClickHandler\n  onOutsideClick={() =&gt; {\n    console.log(\"I am called whenever click happens outside of 'AnyOtherReactComponent' component\")\n  }}\n&gt;\n  &lt;AnyOtherReactComponent /&gt;\n&lt;/OutsideClickHandler&gt;</code></pre>\n</div>\n\n<p><code>OutsideClickHandler</code> takes in two props:</p>\n<ol>\n<li><p><code>children</code><br />It could be any valid React children. In the example above we are passing <code>AnyOtherReactComponent</code> component as <code>OutsideClickHandler</code>‚Äôs child.</p>\n</li>\n<li><p><code>onOutsideClick</code><br />This function will be called if a click happens anywhere outside of <code>AnyOtherReactComponent</code> component.</p>\n</li>\n</ol>\n<p>Sounds good so far? Let‚Äôs actually start building our <code>OutsideClickHandler</code> component.</p>\n<pre><code>import React from 'react';\n\nclass OutsideClickHandler extends React.Component {\n  render() {\n    return this.props.children;\n  }\n}</code></pre>\n\n<p>Just a basic React component. So far, we are not doing much with it. We‚Äôre just returning the children as they are passed to our <code>OutsideClickHandler</code> component. Let‚Äôs wrap the <code>children</code> with a div element and attach a React ref to it.</p>\n<pre><code>import React, { createRef } from 'react';\n\nclass OutsideClickHandler extends React.Component {\n  wrapperRef = createRef();\n\n  render() {    \n    return (\n      &lt;div ref={this.wrapperRef}&gt;\n        {this.props.children}\n      &lt;/div&gt;\n    )\n  }  \n}</code></pre>\n\n<p>We‚Äôll use this <code>ref</code> to get access to the DOM node object associated with the <code>div</code> element. Using that, we‚Äôll recreate the outside detection logic we made above.</p>\n<p>Let‚Äôs attach <code>mousedown</code> event on document inside <code>componentDidMount</code> React life cycle method, and clean up that event inside <code>componentWillUnmount</code> React lifecycle method.</p>\n<div>\n<pre><code>class OutsideClickHandler extends React.Component {\n  componentDidMount() {\n    document\n      .addEventListener('mousedown', this.handleClickOutside);\n  }\n\n  componentWillUnmount(){\n    document\n      .removeEventListener('mousedown', this.handleClickOutside);\n  }\n\n  handleClickOutside = (event) =&gt; {\n    // Here, we'll write the same outside click\n    // detection logic as we used before.\n  }\n}</code></pre>\n</div>\n\n<p>Now, let‚Äôs write the detection code inside <code>handleClickOutside</code> handler function.</p>\n<pre><code>class OutsideClickHandler extends React.Component {\n  componentDidMount() {\n    document\n      .addEventListener('mousedown', this.handleClickOutside);\n  }\n\n  componentWillUnmount(){\n    document\n      .removeEventListener('mousedown', this.handleClickOutside);\n  }\n\n  handleClickOutside = (event) =&gt; {\n    if (\n      this.wrapperRef.current &amp;&amp;\n      !this.wrapperRef.current.contains(event.target)\n    ) {\n      this.props.onOutsideClick();\n    }\n  }\n}</code></pre>\n\n<p>The logic inside <code>handleClickOutside</code> method says the following: </p>\n<blockquote>\n<p>If the DOM node that was clicked (<code>event.target</code>) was neither our container div (<code>this.wrapperRef.current</code>) nor was it any node inside of it (<code>!this.wrapperRef.current.contains(event.target)</code>), we call the <code>onOutsideClick</code> prop.</p>\n</blockquote>\n<p>This should work in the same way as the outside click detection had worked before. Let‚Äôs try clicking outside of the grey text element in the codesandbox below, and observe the console:</p>\n\n\n\n\n<h3>The Problem With DOM Hierarchy Based Outside Click Detection Logic</h3>\n<p>But there‚Äôs one problem. Our React component doesn‚Äôt work if any of its children are rendered in a React portal.</p>\n<p>But what are React portals?</p>\n<blockquote><p>‚ÄúPortals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.‚Äù<br /><br />‚Äî  <a href=\"https://reactjs.org/docs/portals.html)\">React docs for portals</a></p></blockquote>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/62a69c53-9538-45eb-b4d3-6d10b859317d/1-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>In the image above, you can see that though <code>Tooltip</code> React component is a child of <code>Container</code> React component, if we inspect the DOM we find that Tooltip DOM node actually resides in a completely separate DOM structure i.e. it‚Äôs not inside the Container DOM node.</p>\n<p>The problem is that in our outside detection logic so far, we are assuming that the children of <code>OutsideClickHandler</code> will be its direct descendants in the DOM tree. Which is not the case for React portals. If children of our component render in a React portal ‚Äî which is to say they render in a separate DOM node which is outside the hierarchy of our <code>container div</code> in which our <code>OutsideClickHandler</code> component renders its children ‚Äî then the <code>Node.contains</code> logic fails.</p>\n<p>How would it fail though? If you‚Äôd try to click on the children of our <code>OutsideClickHandler</code> component ‚Äî which renders in a separate DOM node using React portals ‚Äî our component will register an outside click, which it shouldn‚Äôt. See for yourself:</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/29410830-efab-4e81-96bd-c718cf34ef13/6-creating-outside-focus-click-handler-react-component.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/abe4349b-5655-428e-9a5a-6650bd93de16/6-creating-outside-focus-click-handler-react-component-800w.gif\" /></a>Using <code>Node.contains</code> to detect outside click of React component gives wrong result for children rendered in a React portal. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/29410830-efab-4e81-96bd-c718cf34ef13/6-creating-outside-focus-click-handler-react-component.gif\">Large preview</a>)\n\n<p>Try it out:</p>\n\n\n<p>Even though the popover that opens on clicking the button, is a child of <strong>OutsideClickHandler</strong> component, it fails to detect that it isn‚Äôt outside of it, and closes it down when it‚Äôs clicked.</p>\n<h3>Using Class Instance Property And Event Delegation To Detect Outside Click</h3>\n<p>So what could be the solution? We surely can‚Äôt rely on DOM to tell us if the click is happening outside anywhere. We‚Äôll have to do something with JavaScript by rewriting out <strong>OutsideClickHandler</strong> implementation.</p>\n<p>Let‚Äôs start with a blank slate. So at this moment <strong>OutsideClickHandler</strong> is an empty React class.</p>\n<p>The crux of correctly detecting outside click is:</p>\n<ol>\n<li>To not rely on DOM structure.</li>\n<li>To store the ‚Äòclicked‚Äô state somewhere in the JavaScript code.</li>\n</ol>\n<p>For this event delegation will come to our aid. Let‚Äôs take an example of the same button and popover example we saw above in the GIF above.</p>\n<p>We have two children of our <strong>OutsideClickHandler</strong> function. A button and a popover ‚Äî which gets rendered in a portal outside of the DOM hierarchy of <strong>OutsideClickHandler</strong>, on button click, like so: </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a1a55a0e-2033-4e26-9019-dad3d5340071/2-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>When either of our children are clicked we set a variable <code>clickCaptured</code> to <code>true</code>. If anything outside of them is clicked, the value of <code>clickCaptured</code> will remain <code>false</code>.</p>\n<p>We will store <code>clickCaptured</code>‚Äôs value in:</p>\n<ol>\n<li>A class instance property, if you are using a class react component.</li>\n<li>A ref, if you are using a functional React component.</li>\n</ol>\n<p>We aren‚Äôt using React state to store <code>clickCaptured</code>‚Äôs value because we aren‚Äôt rendering anything based off of this <code>clickCaptured</code> data. The purpose of <code>clickCaptured</code> is ephemeral and ends as soon as we‚Äôve detected if the click has happened inside or outside.</p>\n<p>Let‚Äôs seee in the image below the logic for setting <code>clickCaptured</code>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/879063d5-ffb0-4b50-88ea-5f5196d62fad/3-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>Whenever a click happens anywhere, it bubbles up in React by default. It‚Äôll reach to the <code>document</code> eventually.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/35d75325-af9e-4160-a667-f4857839dbeb/4-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>When the click reaches <code>document</code>, there are two things that might have happened:</p>\n<ol>\n<li><code>clickCaptured</code> will be true, if children where clicked.</li>\n<li><code>clickCaptured</code> will be false, if anywhere outside of them was clicked.</li>\n</ol>\n<p>In the document‚Äôs event listener we will do two things now:</p>\n<ol>\n<li>If <code>clickCaptured</code> is true, we fire an outside click handler that the user of <strong>OutsideClickHandler</strong> might have given us through a prop.</li>\n<li>We reset <code>clickCaptured</code> to <strong>false</strong>, so that we are ready for another click detection.</li>\n</ol>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8157d7f6-976d-43f0-9197-40f1bf28fddb/5-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>Let‚Äôs translate this into code.</p>\n<pre><code>import React from 'react'\n\nclass OutsideClickHandler extends React.Component {\n  clickCaptured = false;\n\n  render() {\n    if ( typeof this.props.children === 'function' ) {\n      return this.props.children(this.getProps())\n    }\n\n    return this.renderComponent()\n  }\n}</code></pre>\n\n<p>We have the following things:</p>\n<ol>\n<li>set initial value of <code>clickCaptured</code> instance property to <code>false</code>.</li>\n<li>In the <code>render</code> method, we check if <code>children</code> prop is a function. If it is, we call it and pass it all the props we want to give it by calling <code>getProps</code> class method. We haven‚Äôt implemented <code>getProps</code> just yet.</li>\n<li>If the <code>children</code> prop is not a function, we call <code>renderComponent</code> method. Let‚Äôs implement this method now.</li>\n</ol>\n<pre><code>class OutsideClickHandler extends React.Component {\n  renderComponent() {\n    return React.createElement(\n      this.props.component || 'span',\n      this.getProps(),\n      this.props.children\n    )\n  }\n}</code></pre>\n\n<p>Since we aren‚Äôt using JSX, we are directly using React‚Äôs <a href=\"https://reactjs.org/docs/react-api.html#createelement\"><strong>createElement</strong></a> API to wrap our children in either <code>this.props.component</code> or a <code>span</code>. <code>this.props.component</code> can be a React component or any of the HTML element‚Äôs tag name like ‚Äòdiv‚Äô, ‚Äòsection‚Äô, etc. We pass all the props that we want to pass to our newly created element by calling <code>getProps</code> class method as the second argument.</p>\n<p>Let‚Äôs write the <code>getProps</code> method now:</p>\n<pre><code>class OutsideClickHandler extends React.Component {\n  getProps() {\n    return {\n      onMouseDown: this.innerClick,\n      onTouchStart: this.innerClick\n    };\n  }\n}</code></pre>\n\n<p>Our newly created React element, will have the following props passed down to it: <code>onMouseDown</code> and <code>onTouchStart</code> for touch devices. Both of their values is the <code>innerClick</code> class method.</p>\n<pre><code>class OutsideClickHandler extends React.Component {\n  innerClick = () =&gt; {\n    this.clickCaptured = true;\n  }\n}</code></pre>\n\n<p>If our new React component or anything inside of it ‚Äî which could be a React portal ‚Äî is clicked, we set the <code>clickCaptured</code> class instance property to true. Now, let‚Äôs add the <code>mousedown</code> and <code>touchstart</code> events to the document, so that we can capture the event that is bubbling up from below.</p>\n<div>\n<pre><code>class OutsideClickHandler extends React.Component {\n  componentDidMount(){\n    document.addEventListener('mousedown', this.documentClick);\n    document.addEventListener('touchstart', this.documentClick);\n  }\n\n  componentWillUnmount(){\n    document.removeEventListener('mousedown', this.documentClick);\n    document.removeEventListener('touchstart', this.documentClick);\n  }\n\n  documentClick = (event) =&gt; {\n    if (!this.clickCaptured &amp;&amp; this.props.onClickOutside) {\n      this.props.onClickOutside(event);\n    }\n    this.clickCaptured = false;\n  };\n}</code></pre>\n</div>\n\n<p>In the document <strong>mousedown</strong> and <strong>touchstart</strong> event handlers, we are checking if <code>clickCaptured</code> is falsy. </p>\n<ol>\n<li><code>clickCaptured</code> would only be <code>true</code> if children of our React component would have been clicked.</li>\n<li>If anything else would have been clicked <code>clickCaptured</code> would be <code>false</code>, and we‚Äôd know that outside click has happened.</li>\n</ol>\n<p>If <code>clickCaptured</code> is falsy, we‚Äôll call the <strong>onClickOutside</strong> method passed down in a prop to our <strong>OutsideClickHandler</strong> component.</p>\n<p>That‚Äôs it! Let‚Äôs confirm that if we click inside the popover it doesn‚Äôt get closed now, as it was before:</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5ead1f85-65b9-4af4-836b-de052243a628/9-creating-outside-focus-click-handler-react-component.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1e4786e0-bc77-47da-99c2-af8e9e482586/9-creating-outside-focus-click-handler-react-component-800w.gif\" /></a>Using event delegation logic correctly detects outside click, even if children are rendered in a React portal. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5ead1f85-65b9-4af4-836b-de052243a628/9-creating-outside-focus-click-handler-react-component.gif\">Large preview</a>)\n\n<p>Let‚Äôs try it out:</p>\n\n\n<p>Wonderful!</p>\n<h3>Outside Focus Detection</h3>\n<p>Now let‚Äôs take a step further. Let‚Äôs also add functionality to detect when focus has shifted outside of a React component. It‚Äôs going to be very similar implementation as we‚Äôve done with click detection. Let‚Äôs write the code.</p>\n<div>\n <pre><code>class OutsideClickHandler extends React.Component {\n  focusCaptured = false\n\n  innerFocus = () =&gt; {\n    this.focusCaptured = true;\n  }\n\ncomponentDidMount(){\n    document.addEventListener('mousedown', this.documentClick);\n    document.addEventListener('touchstart', this.documentClick);\n    document.addEventListener('focusin', this.documentFocus);\n  }\n\ncomponentWillUnmount(){\n    document.removeEventListener('mousedown', this.documentClick);\n    document.removeEventListener('touchstart', this.documentClick);\n    document.removeEventListener('focusin', this.documentFocus);\n  }\n\ndocumentFocus = (event) =&gt; {\n    if (!this.focusCaptured &amp;&amp; this.props.onFocusOutside) {\n      this.props.onFocusOutside(event);\n    }\n    this.focusCaptured = false;\n  };\n\ngetProps() { return { onMouseDown: this.innerClick, onTouchStart: this.innerClick, onFocus: this.innerFocus }; }\n</code></pre>\n</div>\n\n<p>Everything‚Äôs added mostly in the same fashion, except for one thing. You might have noticed that though we are adding an <code>onFocus</code> react event handler on our children, we are setting a <code>focusin</code> event listener to our document. Why not a <code>focus</code> event you say? Because,  ü•Åü•Åü•Å, <a href=\"https://github.com/facebook/react/pull/19186\">Starting from v17, React now maps</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>onFocus</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">React event to</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>focusin</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">native event internally.</a></p>\n<p>In case you are using v16 or before, instead of adding a <code>focusin</code> event handler to the document, you‚Äôll have to add a <code>focus</code> event in capture phase instead. So that‚Äôll be:</p>\n<pre><code>document.addEventListener('focus', this.documentFocus, true);</code></pre>\n\n<p>Why in capture phase you might ask? Because as weird as it is, <a href=\"https://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\">focus event doesn‚Äôt bubble up</a>.</p>\n<p>Since I‚Äôm using v17 in all my examples, I‚Äôm going to go ahead use the former. Let‚Äôs see what we have here:</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e2459bd8-4760-4322-b16a-6125eff3866f/8-creating-outside-focus-click-handler-react-component.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2932a3bf-a2ff-497e-adbe-145021e646f8/8-creating-outside-focus-click-handler-react-component-800w.gif\" /></a>React Foco component correctly detecting outside click and focus by using event delegation detection logic. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e2459bd8-4760-4322-b16a-6125eff3866f/8-creating-outside-focus-click-handler-react-component.gif\">Large preview</a>)\n\n<p>Let‚Äôs try it out ourselves, try clicking inside and outside of the pink background. Also use tab and shift + tab keys ( in chrome, firefox, edge ) or Opt/Alt + Tab and Opt/Alt + Shift  + Tab ( in Safari ) to toggle focussing between inner and outer button and see how focus status changes.</p>\n\n\n<h3>Conclusion</h3>\n<p>In this article, we learned that the most straightforward way to detect a click outside of a DOM node in JavaScript is by using <code>Node.contains</code> DOM API. I explained the importance of knowing why using the same method to detect clicks outside of a React component doesn‚Äôt work when the React component has children which render in a React portal. Also, now you know how to use a class instance property alongside an event delegation to correctly detect whether a click happened outside of a React component, as well as how to extend the same detection technique to outside focus detection of a React component with the <code>focusin</code> event caveat.</p>\n<h4>Related Resources</h4>\n<ol>\n<li><a href=\"https://github.com/nanot1m/react-foco\">React Foco Github Repository</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\">mdn documentation for</a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\"><code>Node.contains</code></a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\">DOM api</a></li>\n<li><a href=\"https://reactjs.org/docs/portals.html\">React docs for portals</a></li>\n<li><a href=\"https://reactjs.org/docs/react-api.html#createelement\">React</a> <a href=\"https://reactjs.org/docs/react-api.html#createelement\"><code>createElement</code></a> <a href=\"https://reactjs.org/docs/react-api.html#createelement\">API</a></li>\n<li><a href=\"https://github.com/facebook/react/pull/19186\">React Github codebase Pull Request for mapping</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>onFocus</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">and</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>onBlur</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">methods to internally use</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>focusin</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">and</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>focusout</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">native events.</a></li>\n<li><a href=\"https://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\">Delegating Focus and Blur events</a></li>\n</ol>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"4dea44efceb75cfa4bd91d72e9b0efafd5421aef2a80a383b2ecc48641e2d837","category":"Tech"}