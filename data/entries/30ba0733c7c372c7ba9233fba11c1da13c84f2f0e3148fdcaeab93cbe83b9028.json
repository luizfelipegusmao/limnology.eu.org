{"title":"The User Activation API","link":"https://webkit.org/blog/13862/the-user-activation-api/","date":1676481858000,"content":"<p>As a web developer, you‚Äôve probably noticed that certain APIs only work if an end-user clicks or taps on an HTML element. For example, if you try to run the following code in Safari‚Äôs Web Inspector, it will result in an error:</p>\n<pre><code><span>await</span> <span>navigator</span>.<span>share</span>({ <span>text</span><span>:</span> <span>\"hi\"</span> });\n</code></pre>\n<pre><code>NotAllowedError: The request is not allowed by the user agent or \nthe platform in the current context, possibly because the user denied permission.\n</code></pre>\n<p>This error happens when code is not run as a direct result of the end-user clicking or tapping on an HTML element (e.g., a <code>&lt;button&gt;</code>).</p>\n<p>Having code that runs as a result of an end-user action is what the HTML specification refers to as ‚Äú<strong>user activation</strong>‚Äù. There are a large number of APIs on the web that depend on user activation. Common ones include:</p>\n<ul>\n<li><code>window.open()</code></li>\n<li><code>navigator.share()</code></li>\n<li><code>navigator.wakelock.request()</code></li>\n<li><code>PaymentRequest.prototype.show()</code></li>\n<li>and there are many, many more‚Ä¶</li>\n</ul>\n<h2>So what constitutes a ‚Äúuser activation‚Äù?</h2>\n<p>The HTML spec defines the following events as ‚Äú<a href=\"https://html.spec.whatwg.org/#activation-triggering-input-event\">activation triggering user events</a>‚Äù:</p>\n<ul>\n<li><a href=\"https://w3c.github.io/uievents/#event-type-keydown\"><code>keydown</code></a>, excluding the Escape key and possibly some keys reserved by the browser or OS</li>\n<li><a href=\"https://w3c.github.io/uievents/#event-type-mousedown\"><code>mousedown</code></a></li>\n<li><a href=\"https://w3c.github.io/pointerevents/#the-pointerdown-event\"><code>pointerdown</code></a>, but the <a href=\"https://w3c.github.io/pointerevents/#dom-pointerevent-pointertype\"><code>pointerType</code></a> must be ‚Äúmouse‚Äù</li>\n<li><a href=\"https://w3c.github.io/pointerevents/#the-pointerup-event\"><code>pointerup</code></a>, so long as the <a href=\"https://w3c.github.io/pointerevents/#dom-pointerevent-pointertype\"><code>pointerType</code></a> is not ‚Äúmouse‚Äù</li>\n<li><a href=\"https://w3c.github.io/touch-events/#event-touchend\"><code>touchend</code></a></li>\n</ul>\n<p>Together, this list effectively constitutes ‚Äúuser activation‚Äù. You‚Äôll note the list of events above is really small. It‚Äôs restricted so that certain calls to APIs can only happen as a result of those very distinct end-user actions. This prevents end-users from being accidentally (or deliberately!) spammed with popup windows or other intrusive browser dialogs.</p>\n<p>Now that we know about these special events, we can now write code to take into account user activation:</p>\n<pre><code><span>button</span>.<span>addEventListener</span>(<span>\"click\"</span>, <span>async</span> () <span>=</span><span>&gt;</span> {\n   <span>// This works fine...\n</span>   <span>await</span> <span>navigator</span>.<span>share</span>({<span>text</span><span>:</span> <span>\"hi\"</span>});\n});\n</code></pre>\n<p>So even though we are not specifically listening for a <code>\"mousedown\"</code> event, we know that the activation triggering event has occurred, so our code can run without throwing any errors.</p>\n<h2>End-user protections</h2>\n<p>Now you might be wondering, can one run execute multiple commands that require user activation insingle or multiple event listeners? Consider the following code sample:</p>\n<pre><code><span>button</span>.<span>addEventListener</span>(<span>\"click\"</span>, <span>async</span> () <span>=</span><span>&gt;</span> {\n\n   <span>// This works fine...\n</span>   <span>await</span> <span>navigator</span>.<span>share</span>({<span>text</span><span>:</span> <span>\"hi\"</span>});\n\n   <span>// This will fail...\n</span>   <span>window</span>.<span>open</span>(<span>\"https://example.com\"</span>);\n});\n\n<span>button</span>.<span>addEventListener</span>(<span>\"click\"</span>, <span>async</span> () <span>=</span><span>&gt;</span> {\n   <span>// This will now fail too...\n</span>   <span>window</span>.<span>open</span>(<span>\"https://example.com\"</span>);\n});\n</code></pre>\n<p>But why do the calls to <code>window.open()</code> fail there? To understand that, we need to delve deeper into how browsers handle user activation under the hood.</p>\n<h2>Meet ‚Äútransient‚Äù and ‚Äústicky‚Äù activation</h2>\n<p>When an ‚Äúactivation triggering user event‚Äù occurs what actually happens is that the browser starts an internal timer specifically tied to a browser tab. This timer is not directly exposed to the web page and runs for a short time (a few seconds, maybe). Each browser engine can determine how much time is allocated and it can change for a number of reasons (i.e., it‚Äôs deliberately not observable by JavaScript!). It‚Äôs designed to give your code enough time to perform some particular task (e.g., it could process some image data and then call <code>navigator.share()</code> to share the image with another application).</p>\n<p>In HTML, this timer is called <strong>transient activation</strong>. And while this timer is running, that browser window ‚Äúhas transient activation‚Äù. HTML also defines a concept called <strong>sticky activation</strong>. This simply means that the web page has had transient activation at some point in the past.</p>\n<p>Although rare, some APIs (e.g., Web Audio) use sticky activation to perform some actions.</p>\n<p>Now, the above doesn‚Äôt explain why <code>window.open()</code> failed above. To understand why, we need to now discuss what HTML calls  ‚Äú<a href=\"https://html.spec.whatwg.org/#activation-consuming-api\">activation-consuming APIs</a>‚Äù.</p>\n<h2>APIs that ‚Äúconsume‚Äù the user activation</h2>\n<p>As the name suggests,  ‚Äú<a href=\"https://html.spec.whatwg.org/#activation-consuming-api\">activation-consuming APIs</a>‚Äù consume the user activation. That is, when those APIs are called, they effectively reset the transient activation timer, so the web page no longer has transient activation.</p>\n<p>This behavior is why <code>window.open()</code> fails above: calling <code>navigator.share()</code> consumed the user activation, meaning that <code>window.open()</code> no longer had transient activation (so it fails).</p>\n<p>A list of common APIs that consume transient activation in WebKit:</p>\n<ul>\n<li>Web Notification‚Äôs <code>requestPermission()</code> method.</li>\n<li>Payment Request: the <code>show()</code> method.</li>\n<li>And, as we have already discussed, Web Share‚Äôs <code>share()</code> method. </li>\n</ul>\n<p>This list is not exhaustive, and new APIs are being added to the web all the time that either rely on or consume transient activation.</p>\n<p>As a point of interest: not all APIs consume the user activation. Some only require transient activation but won‚Äôt consume it. That allows multiple asynchronous operations dependent on user activation to take place. Otherwise, it would require the user to click or press on a button over and over again to complete a task, which would be quite annoying for them.</p>\n<h2>Scope of transient activation</h2>\n<p>A really useful thing to know about transient activation is that it‚Äôs scoped to the entire window (or browser tab)! That means that, so long as all <code>iframe</code>s on a page are same-origin, they all have transient activation. However, for security reasons, cross-origin <code>iframe</code>s will not have transient activation.</p>\n<p><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/UserActivation-same-origin.png\" alt=\"Transient activation across all same origin iframes\" width=\"1814\" height=\"384\" srcset=\"https://webkit.org/wp-content/uploads/UserActivation-same-origin.png 1814w, https://webkit.org/wp-content/uploads/UserActivation-same-origin-300x64.png 300w, https://webkit.org/wp-content/uploads/UserActivation-same-origin-1024x217.png 1024w, https://webkit.org/wp-content/uploads/UserActivation-same-origin-768x163.png 768w, https://webkit.org/wp-content/uploads/UserActivation-same-origin-1536x325.png 1536w\" /></p>\n<p>For third-party <code>iframe</code>s to have transient activation, a user must explicitly activate an HTML element inside the third-party <code>iframe</code>. However, once they activate an element then transient activation propagates to the parent and to any <code>iframe</code>s that are same origin to <code>iframe</code> where the activation took place:</p>\n<p><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/BrowserTab-cross-origin.png\" alt=\"Activation propagating to parent frame, to other iframes that match the third-party iframe\" width=\"2132\" height=\"384\" srcset=\"https://webkit.org/wp-content/uploads/BrowserTab-cross-origin.png 2132w, https://webkit.org/wp-content/uploads/BrowserTab-cross-origin-300x54.png 300w, https://webkit.org/wp-content/uploads/BrowserTab-cross-origin-1024x184.png 1024w, https://webkit.org/wp-content/uploads/BrowserTab-cross-origin-768x138.png 768w, https://webkit.org/wp-content/uploads/BrowserTab-cross-origin-1536x277.png 1536w, https://webkit.org/wp-content/uploads/BrowserTab-cross-origin-2048x369.png 2048w\" /></p>\n<p>Security Note: you can (and should!) restrict what capacities third-party iframes have access to by setting the <code>allow=</code> and/or <code>sandbox=</code> attributes, as needed.</p>\n<h2>The <code>UserActivation</code> API</h2>\n<p>To assist developers with dealing with user activation, the HTML standard introduces a simple API to check if a page has transient and/or sticky activation.</p>\n<ul>\n<li><code>navigator.userActivation.isActive</code>:<br />\nReturns true when the window has transient activation.</li>\n<li><code>navigator.userActivation.hasBeenActive</code>:<br />\nReturns true if the window has had transient activation in the past (i.e., ‚Äústicky activation‚Äù).</li>\n</ul>\n<p>So for example, you can do something like:</p>\n<pre><code><span>if</span> (<span>navigator</span>.<span>userActivation</span>.<span>isActive</span>) {\n    <span>await</span> <span>navigator</span>.<span>share</span>({<span>text</span><span>:</span> <span>\"hi\"</span>})\n}\n</code></pre>\n<h2>Limitations and ongoing standards work</h2>\n<p>There are two significant limitations with the current user activation model that standards folks are still grappling with.<br />\nFirstly, consider the following case, where a file takes too long to download and the transient activation timer runs out:</p>\n<pre><code><span>button</span>.<span>onclick</span> <span>=</span> () <span>=</span><span>&gt;</span> {\n    <span>// Slow network + really big file\n</span>    <span>const</span> <span>image</span> <span>=</span> <span>await</span> <span>fetch</span>(<span>\"really-big-file\"</span>);\n\n    <span>// Oh no!!! transient activation expired! üò¢\n</span>    <span>navigator</span>.<span>share</span>({<span>files</span><span>:</span> [<span>image</span>]});\n}   \n</code></pre>\n<p>There are ongoing discussions at the WHATWG and W3C about how we might address the problem above. Unfortunately, we don‚Äôt yet have a solution, but naturally we need some means to extend the transient activation so the code above doesn‚Äôt fail.</p>\n<p>Secondly, there are legitimate use cases for enabling transient activation in a third-party iframe from a first-party document (e.g., to allow a third-party to process a request for payment).  There is ongoing discussions to see if there is some means to safely enable third-party <code>iframe</code>s to also have transient activation in special cases.</p>\n<h2>Automation and testing</h2>\n<p>To help developers deal with tricky edge-cases that could arise from the transient activation unexpectedly expiring, WebKit has been working with other browser vendors to <a href=\"https://github.com/w3c/webdriver/pull/1695\">allow the user activation to be consumed via Web Driver</a>.</p>\n<h2>Conclusion</h2>\n<p>Web APIs being gated on user activation helps keep the user safe from annoying intrusions, like multiple popup windows or notification spam, while allowing developers to do the right thing in response to user interaction. The <code>UserActivation</code> API can help you determine if it‚Äôs OK to call a function that depends on user activation.</p>\n<p>You can try out the User Activation API in <a href=\"https://webkit.org/blog/13639/release-notes-for-safari-technology-preview-160/\">Safari Technology Preview release 160</a> or later.</p>","author":"","siteTitle":"Blog ‚Äì WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"30ba0733c7c372c7ba9233fba11c1da13c84f2f0e3148fdcaeab93cbe83b9028","category":"Tech"}