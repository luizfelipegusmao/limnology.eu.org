{"title":"Image To Text Conversion With React And Tesseract.js (OCR)","link":"https://smashingmagazine.com/2021/06/image-text-conversion-react-tesseract-js-ocr/","date":1624285800000,"content":"<p>Data is the backbone of every software application because the main purpose of an application is to solve human problems. To solve human problems, it is necessary to have some information about them.</p>\n<p>Such information is represented as data, especially through computation. On the web, data is mostly collected in the form of texts, images, videos, and many more. Sometimes, images contain essential texts that are meant to be processed to achieve a certain purpose. These images were mostly processed manually because there was no way to process them programmatically.</p>\n<p>The inability to extract text from images was a data processing limitation I experienced first-hand at my last company. We needed to process scanned gift cards and <strong>we had to do it manually</strong> since we couldn’t extract text from images.</p>\n<p>There was a department called “Operations” within the company that was responsible for manual confirming gift cards and crediting users' accounts. Although we had a website through which users connected with us, the processing of gift cards was carried out manually behind the scenes.</p>\n<p>At the time, our website was built mainly with PHP (Laravel) for the backend and JavaScript (jQuery and Vue) for the frontend. Our technical stack was good enough to work with Tesseract.js provided the issue was considered important by the management.</p>\n<p>I was willing to solve the problem but it was not necessary to solve the problem judging from the business’ or the management’s point of view. After leaving the company, <strong>I decided to do some research</strong> and try to find possible solutions. Eventually, I discovered OCR.</p>\n<h3>What Is OCR?</h3>\n<p>OCR stands for “Optical Character Recognition” or “Optical Character Reader”. It is used to extract texts from images.</p>\n<p>The Evolution Of OCR can be traced to several inventions but <a href=\"http://amodern.net/article/optophonic-reading/\">Optophone</a>, “<a href=\"https://history-computer.com/ModernComputer/Software/Gismo.html\">Gismo</a>” , <a href=\"https://www.pbs.org/wgbh/theymadeamerica/whomade/kurzweil_hi.html\">CCD flatbed scanner</a>, <a href=\"https://www.wired.com/2013/08/remembering-the-apple-newtons-prophetic-failure-and-lasting-ideals/\">Newton MesssagePad</a> and <a href=\"https://opensource.google.com/projects/tesseract\">Tesseract</a> are the major inventions that take character recognition to another level of usefulness.</p>\n<p>So, why use OCR? Well, Optical Character Recognition solves a lot of problems, one of which triggered me to write this article. I realized the ability to extract texts from an image ensures a lot of possibilities such as:</p>\n<ul>\n<li><strong>Regulation</strong><br />Every organization needs to regulate users' activities for some reasons. The regulation might be used to protect users’ rights and secure them from threats or scams.<br />Extracting texts from an image enables an organization to process textual information on an image for regulation, especially when the images are supplied by some of the users.<br />For example, Facebook-like regulation of the number of texts on images used for ads can be achieved with OCR. Also, hiding sensitive content on Twitter is also made possible by OCR.</li>\n<li><strong>Searchability</strong><br />Searching is one of the most common activities, especially on the internet. Searching algorithms are mostly based on manipulating texts. With Optical Character Recognition, it is possible to recognize characters on images and use them to provide relevant image results to users. In short, images and videos are now searchable with the aid of OCR.</li>\n<li><strong>Accessibility</strong><br />Having texts on images has always been a challenge for accessibility and it is the rule of thumb to have few texts on an image. With OCR, screen readers can have access to texts on images to provide some necessary experience to its users.</li>\n<li><strong>Data Processing Automation</strong>\nThe processing of data is mostly automated for scale. Having texts on images is a limitation to data processing because the texts cannot be processed except manually. Optical Character Recognition (OCR) makes it possible to extract texts on images programmatically thereby, ensuring data processing automation especially when it has to do with the processing of texts on images.</li>\n<li><strong>Digitization Of Printed Materials</strong><br />Everything is going digital and there are still a lot of documents to be digitized. Cheques, certificates, and other physical documents can now be digitized with the use of Optical Character Recognition.</li>\n</ul>\n<p>Finding out all the uses above deepened my interests, so I decided to go further by asking a question:</p>\n<blockquote>“How can I use OCR on the web, especially in a React application?”</blockquote>\n\n<p>That question led me to Tesseract.js.</p>\n<h3>What Is Tesseract.js?</h3>\n<p>[<a href=\"https://tesseract.projectnaptha.com/\">Tesseract.js</a> is a JavaScript library that compiles the original <a href=\"https://opensource.google.com/projects/tesseract\">Tesseract </a> from C to JavaScript WebAssembly thereby making OCR accessible in the browser. Tesseract.js engine was originally written in ASM.js and it was later ported to WebAssembly but ASM.js still serves as a backup in some cases when WebAssembly is not supported. </p>\n<p>As stated on the website of Tesseract.js, <strong>it supports more than 100 languages</strong>, automatic text orientation and script detection, a simple interface for reading paragraphs, words and character bounding boxes.</p>\n<p><a href=\"https://opensource.google.com/projects/tesseract\">Tesseract</a> is an optical character recognition engine for various operating systems. It is free software, released under the Apache Licence. Hewlett-Packard developed Tesseract as proprietary software in the 1980s. It was released as open source in 2005 and its development has been sponsored by Google since 2006.</p>\n<p>The latest version, version 4, of Tesseract was released in October 2018 and it contains a new OCR engine that uses a <strong>neural network system based on Long Short-Term Memory</strong> (LSTM) and it is meant to produce more accurate results. </p>\n<h3>Understanding Tesseract APIs</h3>\n<p>To really understand how Tesseract works, we need to break down some of its APIs and their components. According to the Tesseract.js documentation, there are two ways to approach using it. Below is the first approach an its break down:</p>\n<pre><code>Tesseract.recognize(\n  image,language,\n  { \n    logger: m =&gt; console.log(m) \n  }\n)\n.catch (err =&gt; {\n  console.error(err);\n})\n.then(result =&gt; {\n console.log(result);\n})\n}\n</code></pre>\n\n<p>The <code>recognize</code> method takes image as its first argument, language (which can be multiple) as its second argument and <code>{ logger: m =&gt; console.log(me) }</code> as its last argument. The image format supported by Tesseract are jpg, png, bmp and pbm which can only be supplied as elements (img, video or canvas), file object (<code>&lt;input&gt;</code>), blob object, path or URL to an image and base64 encoded image. (<a href=\"https://github.com/naptha/tesseract.js/blob/master/docs/image-format.md\">Read here</a> for more information about all of the image formats Tesseract can handle.)</p>\n<p>Language is supplied as a string such as <code>eng</code>. The <code>+</code> sign could be used to concatenate several languages as in <code>eng+chi_tra</code>. The language argument is used to determine the trained language data to be used in processing of images.</p>\n<p><strong>Note</strong>: <em>You’ll find all of the available languages and their codes over <a href=\"https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html\">here</a>.</em></p>\n<p><code>{ logger: m =&gt; console.log(m) }</code> is very useful to get information about the progress of an image being processed. The logger property takes a function that will be called multiple times as Tesseract processes an image. The parameter to the logger function should be an object with <code>workerId</code>, <code>jobId</code>, <code>status</code> and <code>progress</code> as its properties: </p>\n<div>\n <pre><code>{ workerId: ‘worker-200030’, jobId: ‘job-734747’, status: ‘recognizing text’, progress: ‘0.9’ }\n</code></pre>\n</div>\n\n<p><code>progress</code> is a number between 0 and 1, and it is in percentage to show the progress of an image recognition process.</p>\n<p>Tesseract automatically generates the object as a parameter to the logger function but it can also be supplied manually. As a recognition process is taking place, the <code>logger</code> object properties are <strong>updated every time the function is called</strong>. So, it can be used to show a conversion progress bar, alter some part of an application, or used to achieve any desired outcome.</p>\n<p>The <code>result</code> in the code above is the outcome of the image recognition process. Each of the properties of <code>result</code> has the property bbox as the x/y coordinates of their bounding box.</p>\n<p>Here are the properties of the <code>result</code> object, their meanings or uses: </p>\n<pre><code>{\n  text: \"I am codingnninja from Nigeria...\"\n  hocr: \"&lt;div class='ocr_page' id= ...\"\n  tsv: \"1 1 0 0 0 0 0 0 1486 ...\"\n  box: null\n  unlv: null\n  osd: null\n  confidence: 90\n  blocks: [{...}]\n  psm: \"SINGLE_BLOCK\"\n  oem: \"DEFAULT\"\n  version: \"4.0.0-825-g887c\"\n  paragraphs: [{...}]\n  lines: (5) [{...}, ...]\n  words: (47) [{...}, {...}, ...]\n  symbols: (240) [{...}, {...}, ...]\n}\n</code></pre>\n\n<ul>\n<li><code>text</code>: All of the recognized text as a string.</li>\n<li><code>lines</code>: An array of every recognized line by line of text.</li>\n<li><code>words</code>: An array of every recognized word.</li>\n<li><code>symbols</code>: An array of each of the characters recognized.</li>\n<li><code>paragraphs</code>: An array of every recognized paragraph. We are going to discuss “confidence” later in this write-up.</li>\n</ul>\n<p>Tesseract can also be used more imperatively as in:</p>\n<div>\n <pre><code>import { createWorker } from 'tesseract.js';\n\n  const worker = createWorker({\n  logger: m =&gt; console.log(m)\n  });\n\n  (async () =&gt; {\n  await worker.load();\n  await worker.loadLanguage('eng');\n  await worker.initialize('eng');\n  const { data: { text } } = await     worker.recognize('<a href=\"https://tesseract.projectnaptha.com/img/eng_bw.png')\">https://tesseract.projectnaptha.com/img/eng_bw.png')</a>;\n console.log(text);\n await worker.terminate();\n})();\n</code></pre>\n</div>\n\n<p>This approach is related to the first approach but with different implementations.</p>\n<p><code>createWorker(options)</code> creates a web worker or node child process that creates a Tesseract worker. The worker helps set up the Tesseract OCR engine. The <code>load()</code> method loads the Tesseract core-scripts, <code>loadLanguage()</code> loads any language supplied to it as a string, <code>initialize()</code> makes sure Tesseract is fully ready for use and then the recognize method is used to process the image provided. The terminate() method stops the worker and cleans up everything. </p>\n<p><strong>Note</strong>: <em>Please check <a href=\"https://github.com/naptha/tesseract.js/blob/master/docs/api.md\">Tesseract APIs documentation</a> for more information.</em></p>\n<p>Now, we have to build something to really see how effective Tesseract.js is. </p>\n<h3>What Are We Going To Build?</h3>\n<p>We are going to build a gift card PIN extractor because extracting PIN from a gift card was the issue that led to this writing adventure in the first place.</p>\n<p>We will build a simple <strong>application that extracts the PIN from a scanned gift card</strong>. As I set out to build a simple gift card pin extractor, I will walk you through some of the challenges I faced along the line, the solutions I provided, and my conclusion based on my experience.</p>\n<ul>\n<li><a href=\"https://github.com/smashingmagazine/image-to-text\">Go to source code →</a></li>\n</ul>\n<p>Below is the image we are going to use for testing because it has some realistic properties that are possible in the real world.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6b49bcf9-309c-4c6d-9f35-6d60fafec491/code-from-card.jpg\" /></p>\n<p>We will extract <strong>AQUX-QWMB6L-R6JAU</strong> from the card. So, let’s get started.</p>\n<h3>Installation Of React And Tesseract</h3>\n<p>There is a question to attend to before installing <a href=\"https://reactjs.org/\">React</a> and <a href=\"https://tesseract.projectnaptha.com/\">Tesseract.js</a> and the question is, why using React with Tesseract? Practically, we can use Tesseract with Vanilla JavaScript, any JavaScript libraries or frameworks such React, Vue and Angular.</p>\n<p>Using React in this case is a personal preference. Initially, I wanted to use Vue but I decided to go with React because I am more familiar with React than Vue.</p>\n<p>Now, let’s continue with the installations. </p>\n<p>To install React with create-react-app, you have to run the code below:</p>\n<pre><code>npx create-react-app image-to-text\ncd image-to-text\nyarn add Tesseract.js\n</code></pre>\n\n<p>or</p>\n<pre><code>npm install tesseract.js\n</code></pre>\n\n<p>I decided to go with yarn to install Tesseract.js because I was unable to install Tesseract with npm but yarn got the job done without stress. You can use npm but I recommend installing Tesseract with yarn judging from my experience.</p>\n<p>Now, let’s start our development server by running the code below:</p>\n<pre><code>yarn start\n</code></pre>\n\n<p>or </p>\n<pre><code>npm start\n</code></pre>\n\n<p>After running yarn start or npm start, your default browser should open a webpage that looks like below:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e3c6dda4-e886-4f44-9b47-254528927c40/react-home-page.png\" /></p>\n<p>You could also navigate to <code>localhost:3000</code> in the browser provided the page is not launched automatically.</p>\n<p>After installing React and Tesseract.js, what next?</p>\n<h3>Setting Up An Upload Form</h3>\n<p>In this case, we are going to adjust the home page (App.js) we just viewed in the browser to contain the form we need:</p>\n<div>\n<pre><code>import { useState, useRef } from 'react';\nimport Tesseract from 'tesseract.js';\nimport './App.css';\n\nfunction App() {\n  const [imagePath, setImagePath] = useState(\"\");\n  const [text, setText] = useState(\"\");\n\n  const handleChange = (event) =&gt; {\n    setImage(URL.createObjectURL(event.target.files[0]));\n  }\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;main className=\"App-main\"&gt;\n        &lt;h3&gt;Actual image uploaded&lt;/h3&gt;\n        &lt;img \n           src={imagePath} className=\"App-logo\" alt=\"logo\"/&gt;\n\n          &lt;h3&gt;Extracted text&lt;/h3&gt;\n        &lt;div className=\"text-box\"&gt;\n          &lt;p&gt; {text} &lt;/p&gt;\n        &lt;/div&gt;\n        &lt;input type=\"file\" onChange={handleChange} /&gt;\n      &lt;/main&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App\n</code></pre>\n</div>\n\n<p>The part of the code above that needs our attention at this point is the function <code>handleChange</code>.</p>\n<pre><code>const handleChange = (event) =&gt; {\n    setImage(URL.createObjectURL(event.target.files[0]));\n  }\n</code></pre>\n\n<p>In the function, <code>URL.createObjectURL</code> takes a selected file through <code>event.target.files[0]</code> and creates a reference URL that can be used with HTML tags such as img, audio and video. We used <code>setImagePath</code> to add the URL to the state. Now, the URL can now be accessed with <code>imagePath</code>.</p>\n<pre><code>&lt;img src={imagePath} className=\"App-logo\" alt=\"image\"/&gt;\n</code></pre>\n\n<p>We set the image’s src attribute to <code>{imagePath}</code> to preview it in the browser before processing it.</p>\n<h3>Converting Selected Images To Texts</h3>\n<p>As we have grabbed the path to the image selected, we can pass the image’s path to Tesseract.js to extract texts from it.</p>\n<div>\n<pre><code>\nimport { useState} from 'react';\nimport Tesseract from 'tesseract.js';\nimport './App.css';\n\nfunction App() {\n  const [imagePath, setImagePath] = useState(\"\");\n  const [text, setText] = useState(\"\");\n\n  const handleChange = (event) =&gt; {\n    setImagePath(URL.createObjectURL(event.target.files[0]));\n  }\n\n  const handleClick = () =&gt; {\n\n    Tesseract.recognize(\n      imagePath,'eng',\n      { \n        logger: m =&gt; console.log(m) \n      }\n    )\n    .catch (err =&gt; {\n      console.error(err);\n    })\n    .then(result =&gt; {\n      // Get Confidence score\n      let confidence = result.confidence\n\n      let text = result.text\n      setText(text);\n\n    })\n  }\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;main className=\"App-main\"&gt;\n        &lt;h3&gt;Actual imagePath uploaded&lt;/h3&gt;\n        &lt;img \n           src={imagePath} className=\"App-image\" alt=\"logo\"/&gt;\n\n          &lt;h3&gt;Extracted text&lt;/h3&gt;\n        &lt;div className=\"text-box\"&gt;\n          &lt;p&gt; {text} &lt;/p&gt;\n        &lt;/div&gt;\n        &lt;input type=\"file\" onChange={handleChange} /&gt;\n        &lt;button onClick={handleClick} style={{height:50}}&gt; convert to text&lt;/button&gt;\n      &lt;/main&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App\n</code></pre>\n</div>\n\n<p>We add the function “handleClick” to “App.js and it contains Tesseract.js API that takes the path to the selected image. Tesseract.js takes “imagePath”, “language”, “a setting object”.</p>\n<p>The button below is added to the form to call “handClick” which triggers image-to-text conversion whenever the button is clicked.</p>\n<div>\n<pre><code>&lt;button onClick={handleClick} style={{height:50}}&gt; convert to text&lt;/button&gt;\n</code></pre>\n</div>\n\n<p>When the processing is successful, we access both “confidence” and “text” from the result. Then, we add “text” to the state with “setText(text)”.</p>\n<p>By adding to <code>&lt;p&gt; {text} &lt;/p&gt;</code>, we display the extracted text.</p>\n<p>It is obvious that “text” is extracted from the image but what is confidence?</p>\n<p>Confidence shows how accurate the conversion is. The confidence level is between 1 to 100. 1 stands for the worst while 100 stands for the best in terms of accuracy. It can also be used to determine whether an extracted text should be accepted as accurate or not.</p>\n<p>Then the question is what factors can affect the confidence score or the accuracy of the entire conversion? It is mostly affected by three major factors — the quality and nature of the document used, the quality of the scan created from the document and the processing abilities of the Tesseract engine.</p>\n<p>Now, let’s add the code below to “App.css” to style the application a bit.</p>\n<pre><code>.App {\n  text-align: center;\n}\n\n.App-image {\n  width: 60vmin;\n  pointer-events: none;\n}\n\n.App-main {\n  background-color: #282c34;\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  font-size: calc(7px + 2vmin);\n  color: white;\n}\n\n.text-box {\n  background: #fff;\n  color: #333;\n  border-radius: 5px;\n  text-align: center;\n}\n</code></pre>\n\n<p>Here is the result of my <strong>first test</strong>:</p>\n<h5>Outcome In Firefox</h5>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d6d288c1-5579-424c-b4e5-179ebd4d52ef/test1-outcome-without-preprocessing-firefox.png\" /></p>\n<p>The confidence level of the result above is 64. It is worth noting that the gift card image is dark in color and it definitely affects the result we get.</p>\n<p>If you take a closer look at the image above, you will see the pin from the card is almost accurate in the extracted text. It is not accurate because the gift card is not really clear.</p>\n<p>Oh, wait! What will it look like in Chrome?</p>\n<h5>Outcome In Chrome</h5>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1f0cea51-7167-4a7f-b8b4-aff7751bd0ea/test1-outcome-without-preprocessing-chrome.png\" /></p>\n<p>Ah! The outcome is even worse in Chrome. But why is the outcome in Chrome different from Mozilla Firefox? Different browsers handle images and their colour profiles differently. That means, <strong>an image can be rendered differently depending on the browser</strong>. By supplying pre-rendered <code>image.data</code> to Tesseract, it is likely to produce a different outcome in different browsers because different <code>image.data</code> is supplied to Tesseract depending on the browser in use. Preprocessing an image, as we will see later in this article, will help achieve a consistent result. </p>\n<p>We need to be more accurate so that we can be sure we are getting or giving the right information. So we have to take it a bit further.</p>\n<p>Let’s try more to see if we can achieve the aim in the end.</p>\n<h3>Testing For Accuracy</h3>\n<p>There are a lot of factors that affect an image-to-text conversion with <a href=\"https://tesseract.projectnaptha.com/\">Tesseract.js</a>. Most of these factors revolve around the nature of the image we want to process and the rest depends on how the Tesseract engine handles the conversion.</p>\n<p>Internally, Tesseract preprocesses images before the actual OCR conversion but it doesn’t always give accurate results. </p>\n<p>As a solution, we can preprocess images to achieve accurate conversions. We can binarise, invert, dilate, deskew or rescale an image to preprocess it for <a href=\"https://tesseract.projectnaptha.com/\">Tesseract.js</a>. </p>\n<p><strong>Image pre-processing</strong> is a lot of work or an extensive field on its own. Fortunately, <a href=\"https://p5js.org\">P5.js</a> has provided all the image preprocessing techniques we want to use. Instead of reinventing the wheel or using the whole of the library just because we want to use a tiny part of it, I have copied the ones we need. All the image preprocessing techniques are included in <a href=\"https://gist.github.com/codingnninja/346773f3db379796e5407a825497dc19\">preprocess.js</a>.</p>\n<h4>What Is Binarization?</h4>\n<p>Binarization is the conversion of the pixels of an image to either black or white. We want to binarize the previous gift card to check whether the accuracy will be better or not.</p>\n<p>Previously, we extracted some texts from a gift card but the target PIN was not as accurate as we wanted. So there is a need to find another way to get an accurate result.</p>\n<p>Now, we want to <strong>binarize the gift card</strong>, i.e. we want to convert its pixels to black and white so that we can see whether a better level of accuracy can be achieved or not.</p>\n<p>The functions below will be used for binarization and it is included in a separate file called <a href=\"https://gist.github.com/codingnninja/346773f3db379796e5407a825497dc19\">preprocess.js</a>.</p>\n<div>\n<pre><code>function preprocessImage(canvas) {\n    const ctx = canvas.getContext('2d');\n    const image = ctx.getImageData(0,0,canvas.width, canvas.height);\n    thresholdFilter(image.data, 0.5);\n    return image;\n }\n\n Export default preprocessImage\n</code></pre>\n</div>\n\n<p>What does the code above do?</p>\n<p>We introduce canvas to hold an image data to apply some filters, to pre-process the image, before passing it to Tesseract for conversion.</p>\n<p>The first <code>preprocessImage</code> function is located in <em>preprocess.js</em> and prepares the canvas for use by getting its pixels. The function <code>thresholdFilter</code> binarizes the image by <strong>converting its pixels to either black or white</strong>. </p>\n<p>Let’s call <code>preprocessImage</code> to see if the text extracted from the previous gift card can be more accurate.</p>\n<p>By the time we update App.js, it should now look like the code this:</p>\n<div>\n<pre><code>import { useState, useRef } from 'react';\nimport preprocessImage from './preprocess';\nimport Tesseract from 'tesseract.js';\nimport './App.css';\n\nfunction App() {\n  const [image, setImage] = useState(\"\");\n  const [text, setText] = useState(\"\");\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n\n  const handleChange = (event) =&gt; {\n    setImage(URL.createObjectURL(event.target.files[0]))\n  }\n\n  const handleClick = () =&gt; {\n\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    ctx.drawImage(imageRef.current, 0, 0);\n    ctx.putImageData(preprocessImage(canvas),0,0);\n    const dataUrl = canvas.toDataURL(\"image/jpeg\");\n\n    Tesseract.recognize(\n      dataUrl,'eng',\n      { \n        logger: m =&gt; console.log(m) \n      }\n    )\n    .catch (err =&gt; {\n      console.error(err);\n    })\n    .then(result =&gt; {\n      // Get Confidence score\n      let confidence = result.confidence\n      console.log(confidence)\n      // Get full output\n      let text = result.text\n\n      setText(text);\n    })\n  }\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;main className=\"App-main\"&gt;\n        &lt;h3&gt;Actual image uploaded&lt;/h3&gt;\n        &lt;img \n           src={image} className=\"App-logo\" alt=\"logo\"\n           ref={imageRef} \n           /&gt;\n        &lt;h3&gt;Canvas&lt;/h3&gt;\n        &lt;canvas ref={canvasRef} width={700} height={250}&gt;&lt;/canvas&gt;\n          &lt;h3&gt;Extracted text&lt;/h3&gt;\n        &lt;div className=\"pin-box\"&gt;\n          &lt;p&gt; {text} &lt;/p&gt;\n        &lt;/div&gt;\n        &lt;input type=\"file\" onChange={handleChange} /&gt;\n        &lt;button onClick={handleClick} style={{height:50}}&gt;Convert to text&lt;/button&gt;\n      &lt;/main&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App\n</code></pre>\n</div>\n\n<p>First, we have to import “preprocessImage” from “preprocess.js” with the code below:</p>\n<pre><code>import preprocessImage from './preprocess';\n</code></pre>\n\n<p>Then, we add a canvas tag to the form. We set the ref attribute of both the canvas and the img tags to <code>{ canvasRef }</code> and <code>{ imageRef }</code> respectively. The refs are used to access the canvas and the image from the App component. We get hold of both the canvas and the image with “useRef” as in:</p>\n<pre><code>const canvasRef = useRef(null);\nconst imageRef = useRef(null);\n</code></pre>\n\n<p>In this part of the code, we merge the image to the canvas as we can only preprocess a canvas in JavaScript. We then convert it to a data URL with “jpeg” as its image format.</p>\n<pre><code>const canvas = canvasRef.current;\nconst ctx = canvas.getContext('2d');\n\nctx.drawImage(imageRef.current, 0, 0);\nctx.putImageData(preprocessImage(canvas),0,0);\nconst dataUrl = canvas.toDataURL(\"image/jpeg\");\n</code></pre>\n\n<p>“dataUrl” is passed to Tesseract as the image to be processed.</p>\n<p>Now, let’s check whether the text extracted will be more accurate. </p>\n<h5>Test #2</h5>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7563cb58-f1ef-41ff-abad-6e557b2fdc04/test2-outcome-with-preprocessing-firefox.png\" /></p>\n<p>The image above shows the result in Firefox. It is obvious that the dark part of the image has been changed to white but preprocessing the image doesn’t lead to a more accurate result. It is even worse.</p>\n<p>The first conversion only has <strong>two incorrect characters</strong> but this one has <strong>four</strong> incorrect characters. I even tried changing the threshold level but to no avail. We don’t get a better result not because binarization is bad but because binarizing the image doesn’t fix the nature of the image in a way that is suitable for the Tesseract engine.</p>\n<p>Let’s check what it also looks like in Chrome:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/88447123-e5af-4611-a23f-fcfcd0743192/test2-outcome-with-preprocessing-chrome.png\" /></p>\n<p>We get the same outcome.</p>\n<p>After getting a worse result by binarizing the image, there is a need to check other image preprocessing techniques to see whether we can solve the problem or not. So, we are going to try dilation, inversion, and blurring next.</p>\n<p>Let’s just get the code for each of the techniques from <a href=\"http://p5js.org\">P5.js</a> as used by this <a href=\"https://dev.to/mathewthe2/using-javascript-to-preprocess-images-for-ocr-1jc\">article</a>. We will add the image processing techniques to <a href=\"https://gist.github.com/codingnninja/346773f3db379796e5407a825497dc19\">preprocess.js</a> and use them one by one. It is necessary to understand each of the image preprocessing techniques we want to use before using them, so we are going to discuss them first.</p>\n<h4>What Is Dilation?</h4>\n<p>Dilation is adding pixels to the boundaries of objects in an image to make it wider, larger, or more open. The “dilate” technique is used to preprocess our images to increase the brightness of the objects on the images. We need a function to dilate images using JavaScript,   so the code snippet to dilate an image is added to <a href=\"https://gist.github.com/codingnninja/346773f3db379796e5407a825497dc19\">preprocess.js</a>. </p>\n<h4>What Is Blur?</h4>\n<p>Blurring is smoothing the colors of an image by reducing its sharpness. Sometimes, images have small dots/patches. To remove those patches, we can blur the images. The code snippet to blur an image is included in <a href=\"https://gist.github.com/codingnninja/346773f3db379796e5407a825497dc19\">preprocess.js</a>.</p>\n<h4>What Is Inversion?</h4>\n<p>Inversion is changing light areas of an image to a dark color and dark areas to a light color. For example, if an image has a black background and white foreground, we can invert it so that its background will be white and its foreground will be black. We have also added the code snippet to invert an image to <a href=\"https://gist.github.com/codingnninja/346773f3db379796e5407a825497dc19\">preprocess.js</a>.</p>\n<p>After adding <code>dilate</code>, <code>invertColors</code> and <code>blurARGB</code> to “preprocess.js”, we can now use them to preprocess images. To use them, we need to update the initial “preprocessImage” function in <a href=\"https://gist.github.com/codingnninja/346773f3db379796e5407a825497dc19\">preprocess.js</a>:</p>\n<p><code>preprocessImage(...)</code> now looks like this:</p>\n<div>\n<pre><code>function preprocessImage(canvas) {\n  const level = 0.4;\n  const radius = 1;\n  const ctx = canvas.getContext('2d');\n  const image = ctx.getImageData(0,0,canvas.width, canvas.height);\n  blurARGB(image.data, canvas, radius);\n  dilate(image.data, canvas);\n  invertColors(image.data);\n  thresholdFilter(image.data, level);\n  return image;\n }\n</code></pre>\n</div>\n\n<p>In <code>preprocessImage</code> above, we apply four preprocessing techniques to an image: <code>blurARGB()</code> to remove the dots on the image, <code>dilate()</code> to increase the brightness of the image, <code>invertColors()</code> to switch the foreground and background color of the image and <code>thresholdFilter()</code> to convert the image to black and white which is more suitable for Tesseract conversion.</p>\n<p>The <code>thresholdFilter()</code> takes <code>image.data</code> and <code>level</code> as its parameters. <code>level</code> is used to set how white or black the image should be. We determined the <code>thresholdFilter</code> level and <code>blurRGB</code> radius by trial and error as we are not sure how white, dark or smooth the image should be for Tesseract to produce a great result.</p>\n<h5>Test #3</h5>\n<p>Here is the new result after applying four techniques:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/057c6565-a07e-4fb0-9818-0b68b1cd3dce/test3-outcome-with-preprocessing-firefox-and-chrome.png\" /></p>\n<p>The image above represents the result we get in both Chrome and Firefox.</p>\n<p>Oops! The outcome is terrible.</p>\n<p>Instead of using all four techniques, why don’t we just use two of them at a time?</p>\n<p>Yeah! We can simply use <code>invertColors</code> and <code>thresholdFilter</code> techniques to convert the image to black and white, and switch the foreground and the background of the image. But <strong>how do we know what and what techniques to combine?</strong> We know what to combine based on the nature of the image we want to preprocess.</p>\n<p>For example, a digital image has to be converted to black and white, and an image with patches has to be blurred to remove the dots/patches. What really matters is to understand what each of the techniques is used for. </p>\n<p>To use <code>invertColors</code> and <code>thresholdFilter</code>, we need to comment out both <code>blurARGB</code> and <code>dilate</code> in <code>preprocessImage</code>:</p>\n<div>\n<pre><code>function preprocessImage(canvas) {\n    const ctx = canvas.getContext('2d');\n    const image = ctx.getImageData(0,0,canvas.width, canvas.height);\n    // blurARGB(image.data, canvas, 1);\n    // dilate(image.data, canvas);\n    invertColors(image.data);\n    thresholdFilter(image.data, 0.5);\n    return image;\n}\n</code></pre>\n</div>\n\n<h5>Test #4</h5>\n<p>Now, here is the new outcome:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0663d02f-e960-4d58-bd14-478423c04c8b/test4-outcome-with-preprocessing-firefox-and-chrome.png\" /></p>\n<p>The result is still worse than the one without any preprocessing. After adjusting each of the techniques for this particular image and some other images, I have come to the conclusion that images with different nature require different preprocessing techniques. </p>\n<p>In short, using <a href=\"https://tesseract.projectnaptha.com/\">Tesseract.js</a> without image preprocessing produced the best outcome for the gift card above. All other experiments with image preprocessing yielded less accurate outcomes.</p>\n<h3>Issue</h3>\n<p>Initially, I wanted to extract the PIN from any Amazon gift card but I couldn’t achieve that because there is no point to match an inconsistent PIN to get a consistent result. Although it is possible to process an image to get an accurate PIN, yet such preprocessing will be inconsistent by the time another image with different nature is used.</p>\n<h3>The Best Outcome Produced</h3>\n<p>The image below showcases the best outcome produced by the experiments.</p>\n<h5>Test #5</h5>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/18a22fc4-25a4-40ca-b925-6ffb5f1b3628/test5-best-result-without-preprocessing.png\" /></p>\n<p>The texts on the image and the ones extracted are totally the same. The conversion has 100% accuracy. I tried to reproduce the result but I was only able to reproduce it when using images with similar nature.</p>\n<h3>Observation And Lessons</h3>\n<ul>\n<li>Some images that are not preprocessed may give <strong>different outcomes in different browsers</strong>. This claim is evident in the first test. The outcome in Firefox is different from the one in Chrome. However, preprocessing images helps achieve a consistent outcome in other tests.</li>\n<li>Black color on a white background tends to give manageable results. The image below is an example of an <strong>accurate result without any preprocessing</strong>. I also was able to get the same level of accuracy by preprocessing the image but it took me a lot of adjustment which was unnecessary.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/18a22fc4-25a4-40ca-b925-6ffb5f1b3628/test5-best-result-without-preprocessing.png\" /></p>\n<p>The conversion is 100% accurate.</p>\n<ul>\n<li>A text with a <strong>big font size</strong> tends to be more accurate.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a0eb158c-31d6-4624-b102-0e62a7a7cdd1/test6-outcome-for-text-with-big-fonts.png\" /></p>\n<ul>\n<li>Fonts with <strong>curved edges</strong> tend to confuse Tesseract. The best result I got was achieved when I used Arial (font).</li>\n<li>OCR is currently not good enough for automating image-to-text conversion, especially when more than 80% level of accuracy is required. However, it can be used to make the manual processing of texts on images <strong>less stressful</strong> by extracting texts for manual correction.</li>\n<li>OCR is currently not good enough to pass useful information to screen readers for <strong>accessibility</strong>. Supplying inaccurate information to a screen reader can easily mislead or distract users.</li>\n<li>OCR is very promising as neural networks make it possible to learn and improve. Deep learning will <strong>make OCR a game-changer in the near future</strong>.</li>\n<li>Making decisions with confidence. A confidence score can be used to make decisions that can greatly impact our applications. The confidence score can be used to determine whether to accept or reject a result. From my experience and experiment, I realized that any confidence score below 90 isn’t really useful. If I only need to extract some pins from a text, I will expect a confidence score between 75 and 100, and <strong>anything below 75 will be rejected</strong>. </li>\n</ul>\n<p>In case I am dealing with texts without the need to extract any part of it, I will definitely accept a confidence score between 90 to 100 but reject any score below that. For example, 90 and above accuracy will be expected if I want to digitize documents such as cheques, a historic draft or whenever an exact copy is necessary. But a score that is between 75 and 90 is acceptable when an exact copy is not important such as getting the PIN from a gift card. In short, <strong>a confidence score helps in making decisions</strong> that impact our applications.</p>\n<h3>Conclusion</h3>\n<p>Given the data processing limitation caused by texts on images and the disadvantages associated with it, Optical Character Recognition (OCR) is a useful technology to embrace. Although OCR has its limitations, it is very promising because of its use of neural networks.</p>\n<p>Over time, OCR will overcome most of its limitations with the help of deep learning, but before then, the approaches highlighted in this article can be utilized to deal with text extraction from images, at least, to <strong>reduce the hardship and losses associated with manual processing</strong> — especially from a business point of view.</p>\n<p>It is now your turn to try OCR to extract texts from images. Good luck!</p>\n<h4>Further Reading</h4>\n<ul>\n<li><a href=\"https://p5js.org/\">P5.js</a></li>\n<li><a href=\"https://towardsdatascience.com/pre-processing-in-ocr-fc231c6035a7\">Pre-Processing in OCR</a></li>\n<li><a href=\"https://tesseract-ocr.github.io/tessdoc/ImproveQuality\">Improving the quality of the output</a></li>\n<li><a href=\"https://dev.to/mathewthe2/using-javascript-to-preprocess-images-for-ocr-1jc\">Using JavaScript to Preprocess Images for OCR</a></li>\n<li><a href=\"https://golb.hplar.ch/2019/07/ocr-with-tesseractjs.html\">OCR in the browser with Tesseract.js</a></li>\n<li><a href=\"https://medium.com/ocrology/a-quick-history-of-optical-character-recognition-ocr-c916d58e2170\">A Quick History of Optical Character Recognition</a></li>\n<li><a href=\"https://www.forbes.com/sites/forbestechcouncil/2019/09/10/the-future-of-ocr-is-deep-learning/?sh=8bf8fec6a049\">The Future of OCR is Deep Learning</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Timeline_of_optical_character_recognition\">Timeline of Optical Character Recognition</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"5d0c22b3db169e266f4c08e5b151a1a8ece7a2e11e830b82c3c3c17481a9d5c3","category":"Tech"}