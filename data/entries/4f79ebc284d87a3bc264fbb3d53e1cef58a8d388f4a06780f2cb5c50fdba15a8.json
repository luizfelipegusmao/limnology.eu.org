{"title":"Integrating A Dialogflow Agent Into A React Application","link":"https://smashingmagazine.com/2021/01/dialogflow-agent-react-application/","date":1610634613000,"content":"<p>Dialogflow is a platform that simplifies the process of creating and designing a natural language processing conversational chat assistant which can process voice or text input when being used either from the Dialogflow console or from an integrated web application.</p>\n<p>Although the integrated Dialogflow Agent is briefly explained in this article, it is expected that you have an understanding of <a href=\"https://nodejs.org/\">Node.js</a> and Dialogflow. If you are learning about Dialogflow for the first time, <a href=\"https://www.smashingmagazine.com/2020/12/conversational-nlp-enabled-chatbot-google-dialogflow/\">this article</a> gives a clear explanation of what <a href=\"https://cloud.google.com/dialogflow/docs\">Dialogflow</a> is and its concepts.</p>\n<p>This article is a guide on how a built a Dialogflow agent with voice and chat support that can be integrated into a web application with the help of an <a href=\"https://expressjs.com/\">Express.js</a> back-end application as a link between a <a href=\"https://reactjs.org/\">React.js</a> Web application and the Agent on Dialogflow itself. By the end of the article, you should able to connect your own Dialogflow agent to your preferred web application. </p>\n<p>To make this guide easy to follow through, you can skip to whichever part of the tutorial interests you most or follow them in the following order as they appear:</p>\n<ul>\n    <li><a href=\"#setting-up-dialogflow-agent\">Setting Up A Dialogflow Agent</a></li>\n    <li><a href=\"#integrating-dialogflow\">Integrating A Dialogflow Agent</a></li>\n    <li><a href=\"#setting-up-node-express-app\">Setting Up A Node Express Application</a></li>\n    <ul>\n        <li><a href=\"#authenticating-dialogflow\">Authenticating With Dialogflow</a></li>\n        <li><a href=\"#service-accounts\">What Are Service Accounts?</a></li>\n        <li><a href=\"#handling-voice-inputs\">Handling Voice Inputs</a></li>\n    </ul>\n    <li><a href=\"#integrating-web-app\">Integrating Into A Web Application</a></li>\n    <ul>\n        <li><a href=\"#creating-chat-interface\">Creating A Chat Interface</a></li>\n        <li><a href=\"#recording-user-voice-input\">Recording User Voice Input</a></li>\n    </ul>\n    <li><a href=\"#conclusion\">Conclusion</a></li>\n    <li><a href=\"#references\">References</a></li>\n</ul>\n\n<h3>1. Setting Up A Dialogflow Agent</h3>\n\n<p>As explained in <a href=\"https://www.smashingmagazine.com/2020/12/conversational-nlp-enabled-chatbot-google-dialogflow/\">this</a> article, a chat assistant on <a href=\"https://cloud.google.com/dialogflow/docs\">Dialogflow</a> is called an <a href=\"https://cloud.google.com/dialogflow/es/docs/agents-overview\">Agent</a> and it comprises of smaller components such as <a href=\"https://cloud.google.com/dialogflow/es/docs/intents-overview\">intents</a>, <a href=\"https://cloud.google.com/dialogflow/es/docs/fulfillment-overview\">fulfillment</a>, <a href=\"https://cloud.google.com/dialogflow/es/docs/how/knowledge-bases\">knowledge base</a> and much more. Dialogflow provides a <a href=\"https://cloud.google.com/dialogflow/es/docs/console\">console</a> for users to create, train, and design the conversation flow of an Agent. In our use case, we will restore an agent that was exported into a ZIP folder after being trained, using the agent <a href=\"https://cloud.google.com/dialogflow/es/docs/agents-settings#export\">Export and Import</a> feature.</p>\n<p>Before we perform the import, we need to create a new agent that will be merged with the agent about to be restored. To create a new Agent from the console, a unique name is needed and also, a project on the <a href=\"https://cloud.google.com/docs\">Google Cloud</a> to link the agent with. If there is no existing project on the Google Cloud to link with, a new one can be created <a href=\"https://console.cloud.google.com/\">here</a>.</p>\n<p>An agent has been previously created and trained to recommend wine products to a user based on their budget. This agent has been exported into a ZIP; you can <a href=\"https://res.cloudinary.com/dkfptto8m/raw/upload/v1608642166/blog/dialogflow-recommender-agent.zip\">download the folder here</a> and restore it into our newly created agent from the <a href=\"https://cloud.google.com/dialogflow/es/docs/agents-settings#export\">Export and Import</a> tab found in the agent Settings page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fe4910cb-40a7-4232-9b8a-fac7052f728f/dialogflow-agent-restore.png\" /></p>\n<p>The imported agent has been previously trained to recommend a wine product to the user based on the user‚Äôs budget for purchasing a bottle of wine. </p>\n<p>Going through the imported agent, we will see it has three created intents from the intents page. One being a fallback intent, used when the Agent does not recognize input from a user, the other is a Welcome intent used when a conversation with the Agent is started, and the last intent is used to recommend a wine to the user based on the amount parameter within the sentence. Of concern to us is the <code>get-wine-recommendation</code> intent</p>\n<p>This intent has a single input <a href=\"https://cloud.google.com/dialogflow/es/docs/contexts-overview\">context</a> of <code>wine-recommendation</code> coming from the Default Welcome intent to link the conversation to this intent.</p>\n<blockquote>‚ÄúA <a href=\"https://cloud.google.com/dialogflow/es/docs/contexts-overview\">Context</a> is a system within an Agent used to control the flow of a conversation from one intent to the other.‚Äù</blockquote>\n\n<p>Below the <a href=\"https://cloud.google.com/dialogflow/es/docs/contexts-overview\">contexts</a> are the <a href=\"https://cloud.google.com/dialogflow/es/docs/intents-training-phrases\">Training phrases</a>, which are sentences used to train an agent on what type of statements to expect from a user. Through a large variety of training phrases within an intent, an agent is able to recognize a user‚Äôs sentence and the intent it falls into.</p>\n<p>The training phrases within our agents <code>get-wine-recommendation</code> intent (as shown below) indicates the wine choice and the price category:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a51a434d-ddad-4d99-9da9-4c6f9eb5223b/training-phrases.png\" /></p>\n<p>Looking at the image above, we can see the available training phrases listed out, and the currency figure is highlighted in yellow color for each of them. This highlighting is known as an annotation on Dialogflow and it is automatically done to extract the recognized data types known as an entity from a user‚Äôs sentence. </p>\n<p>After this intent has been matched in a conversation with the agent, an HTTP request will be made to an external service to get the recommended wine based on the price extracted as a parameter from a user‚Äôs sentence, through the use of the enabled webhook found within the Fulfillment section at the bottom of this intent page. </p>\n<p>We can test the agent using the Dialogflow emulator located in the right section of the Dialogflow console. To test, we start the conversation with a ‚Äú<strong>Hi</strong>‚Äù message and follow up with the desired amount of wine. The webhook will immediately be called and a rich response similar to the one below will be shown by the agent.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3baee8fd-6532-4e96-8622-9ed959fe325f/console-emulator-test.png\" /></p>\n<p>From the image above we can see the webhook URL generated using <a href=\"https://ngrok.com/\">Ngrok</a> and the agent‚Äôs response on the right-hand side showing a wine within the $20 price range typed in by the user.</p>\n<p>At this point, the Dialogflow agent has been fully setup. We can now get started with integrating this agent into a web application to enable other users to access and interact with the agent without access to our <a href=\"https://cloud.google.com/dialogflow/es/docs/console\">Dialogflow console</a>.</p>\n<h3>Integrating A Dialogflow Agent</h3>\n\n<p>While there are other means of connecting to a Dialogflow Agent such as making HTTP requests to its <a href=\"https://cloud.google.com/dialogflow/es/docs/reference/rest/v2-overview\">REST endpoints</a>, the recommended way to connect to Dialogflow is through the use of its official client library available in several programming languages. For JavaScript, the <a href=\"https://www.npmjs.com/package/@google-cloud/dialogflow\">@google-cloud/dialogflow</a> package is available for installation from <a href=\"https://www.npmjs.com/\">NPM</a>.</p>\n<p>Internally the <a href=\"https://www.npmjs.com/package/@google-cloud/dialogflow\">@google-cloud/dialogflow</a> package uses <a href=\"https://grpc.io/\">gRPC</a> for its network connections and this makes the package unsupported within a browser environment except when patched using <a href=\"https://webpack.js.org/\">webpack</a>, the recommended way to use this package is from a Node environment. We can do this by setting up an Express.js back-end application to use this package then serve data to the web application through its API endpoints and this is what we will do next. </p>\n<h3>Setting Up A Node Express Application</h3>\n\n<p>To set up an express application we create a new project directory then grab the needed dependencies using <code>yarn</code> from an opened command line terminal.</p>\n<pre><code># create a new directory and ( &amp;&amp; ) move into directory\nmkdir dialogflow-server &amp;&amp; cd dialogflow-server\n\n# create a new Node project\nyarn init -y\n\n# Install needed packages\nyarn add express cors dotenv uuid\n</code></pre>\n\n<p>With the needed dependencies installed, we can proceed to set up a very lean Express.js server that handles connections on a specified port with CORS support enabled for the web app.</p>\n<div>\n<pre><code>// index.js\nconst express =  require(\"express\")\nconst dotenv =  require(\"dotenv\")\nconst cors =  require(\"cors\")\n\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.use(cors());\n\napp.listen(PORT, () =&gt; console.log(<code>üî•  server running on port ${PORT}</code>));</code></pre>\n</div>\n\n<p>When executed, the code in the snippet above starts an HTTP server that listens for connections on a specified PORT Express.js. It also has <a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">Cross-origin resource sharing</a> (CORS) enabled on all requests using the <a href=\"https://www.npmjs.com/package/cors\">cors</a> package as an <a href=\"https://expressjs.com/en/guide/using-middleware.html\">Express middleware</a>. For now, this server only listens for connections, it cannot respond to a request because it has no created <a href=\"https://expressjs.com/en/guide/routing.html\">route</a>, so let‚Äôs create this.</p>\n<p>We now need to add two new routes: one for sending text data while the other for sending a recorded voice input. They will both accept a <code>POST</code> request and send the data contained in the request body to the Dialogflow agent later on.</p>\n<div>\n<pre><code>const express = require(\"express\") \n\nconst app = express()\n\napp.post(\"/text-input\", (req, res) =&gt; {\n  res.status(200).send({ data : \"TEXT ENDPOINT CONNECTION SUCCESSFUL\" })\n});\n\napp.post(\"/voice-input\", (req, res) =&gt; {\n  res.status(200).send({ data : \"VOICE ENDPOINT CONNECTION SUCCESSFUL\" })\n});\n\nmodule.exports = app</code></pre>\n</div>\n\n<p>Above we created a separate router instance for the two created <code>POST</code> routes which for now,  only respond with a <code>200</code> status code and a hardcoded dummy response. When we are done authenticating with Dialogflow, we can come back to implement an actual connection to Dialogflow within these endpoints.</p>\n<p>For the last step in our backend application setup, we mount the previously created router instance created into the Express application using <a href=\"https://expressjs.com/en/api.html#app.use\">app.use</a> and a base path for the route.</p>\n<div>\n<pre><code>// agentRoutes.js\n\nconst express =  require(\"express\")\nconst dotenv =  require(\"dotenv\")\nconst cors =  require(\"cors\")\n\nconst Routes =  require(\"./routes\")\n\ndotenv.config();\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.use(cors());\n\napp.use(\"/api/agent\", Routes);\n\napp.listen(PORT, () =&gt; console.log(<code>üî•  server running on port ${PORT}</code>));\n</code></pre>\n</div>    \n\n<p>Above, we have added a base path to the two routes two we can test any of them via a <code>POST</code> request using <a href=\"https://curl.se/\">cURL</a> from a command line as it‚Äôs done below with an empty request body;</p>\n<pre><code>curl -X http://localhost:5000/api/agent/text-response</code></pre>\n\n<p>After successful completion of the request above, we can expect to see a response containing object data being printed out to the console.</p>\n<p>Now we are left with making an actual connection with Dialogflow which includes handling authentication, sending, and receiving data from the Agent on Dialogflow using the <a href=\"https://www.npmjs.com/package/@google-cloud/dialogflow\">@google-cloud/dialogflow</a> package.  </p>\n<h4>Authenticating With Dialogflow</h4>\n\n<p>Every Dialogflow agent created is linked to a project on the <a href=\"https://cloud.google.com/\">Google Cloud</a>. To connect externally to the Dialogflow agent, we authenticate with the project on the Google cloud and use Dialogflow as one of the project‚Äôs resources. Out of the six <a href=\"https://cloud.google.com/endpoints/docs/openapi/authentication-method\">available</a> ways to connect to a project on the google-cloud, using the <a href=\"https://cloud.google.com/endpoints/docs/openapi/authentication-method#service_accounts\">Service accounts</a> option is the most convenient when connecting to a particular service on the google cloud through its client library. </p>\n<p><strong>Note</strong>: <em>For production-ready applications, the use of short-lived API keys are recommended over Service Account keys in order to reduce the risk of a service account key getting into the wrong hands.</em></p>\n<h4>What Are Service Accounts?</h4>\n\n<p><a href=\"https://cloud.google.com/iam/docs/understanding-service-accounts\">Service accounts</a> are a special type of account on the <a href=\"https://cloud.google.com/\">Google Cloud</a>, created for non-human interaction, mostly through external APIs. In our application, the service account will be accessed through a generated key by the Dialogflow <a href=\"https://www.npmjs.com/package/@google-cloud/dialogflow\">client library</a> to authenticate with the Google Cloud.</p>\n<p>The cloud documentation on creating and managing service accounts provides an excellent <a href=\"https://cloud.google.com/iam/docs/creating-managing-service-accounts\">guide</a> to create a service account. When creating the service account, the <a href=\"https://cloud.google.com/dialogflow/es/docs/access-control\">Dialogflow API Admin</a> role should be assigned to the created service account as shown in the last step. This role gives the service account administrative control over the linked Dialogflow agent.</p>\n<p>To use the service account, we need to create a <a href=\"https://cloud.google.com/iam/docs/creating-managing-service-account-keys\">Service Account Key</a>. The following steps below outline how to create one in JSON format:</p>\n<ol>\n<li>Click on the newly created Service Account to navigate to the Service account page.</li>\n<li>Scroll to the Keys section and click the <strong>Add Key</strong> dropdown and click on the <strong>Create new key</strong> option which opens a modal.</li>\n<li>Select a <a href=\"https://json.org/\">JSON</a> file format and click the Create button at the bottom right of the modal.</li>\n</ol>\n<p><strong>Note:</strong> <em>It is recommended to keep a service account key private and not commit it to any</em> <a href=\"https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control\"><em>version control system</em></a> <em>as it contains highly sensitive data about a project on the Google Cloud. This can be done by adding the file to the <code>.gitignore</code> file.</em></p>\n<p>With a service account created and a service account key available within our project‚Äôs directory, we can use the Dialogflow client library to send and receive data from the Dialogflow agent.</p>\n<pre><code>// agentRoute.js\nrequire(\"dotenv\").config();\n\nconst express = require(\"express\")\nconst Dialogflow = require(\"@google-cloud/dialogflow\")\nconst { v4 as uuid } = require(\"uuid\")\nconst Path = require(\"path\")\n\nconst app = express();\n\napp.post(\"/text-input\", async (req, res) =&gt; {\n  const { message } = req.body;\n\n  // Create a new session\n   const sessionClient = new Dialogflow.SessionsClient({\n    keyFilename: Path.join(__dirname, \"./key.json\"),\n  });\n\n  const sessionPath = sessionClient.projectAgentSessionPath(\n    process.env.PROJECT_ID,\n    uuid()\n  );\n\n  // The dialogflow request object\n  const request = {\n    session: sessionPath,\n    queryInput: {\n      text: {\n        // The query to send to the dialogflow agent\n        text: message,\n      },\n    },\n  };\n\n  // Sends data from the agent as a response\n  try {\n    const responses = await sessionClient.detectIntent(request);\n    res.status(200).send({ data: responses });\n  } catch (e) {\n    console.log(e);\n    res.status(422).send({ e });\n  }\n});\n\nmodule.exports = app;\n</code></pre>\n\n<p>The entire route above sends data to the Dialogflow agent and receives a response through the following steps.</p>\n<ul>\n<li><strong>First</strong><br />It authenticates with the Google cloud then it creates a session with Dialogflow using the projectID of Google cloud project linked to the Dialogflow agent and also a random ID to identify the session created. In our application, we are creating a <a href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier\">UUID</a> identifier on each session created using the JavaScript <a href=\"https://www.npmjs.com/package/uuid\">UUID</a> package. This is very useful when logging or tracing all conversations handled by a Dialogflow agent.</li>\n<li><strong>Second</strong><br />We create a request object data following the specified format in the Dialogflow documentation. This request object contains the created session and the message data gotten from the request body which is to be passed to the Dialogflow agent.</li>\n<li><strong>Third</strong><br />Using the <code>detectIntent</code> method from the Dialogflow session, we send the request object asynchronously and await the Agent‚Äôs response using ES6 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">async / await</a> syntax in a try-catch block should the <code>detectIntent</code> method return an exception, we can catch the error and return it, rather than crashing the entire application. A sample of the response object returned from the Agent is provided in the Dialogflow documentation and can be inspected to know how to extract the data from the object. </li>\n</ul>\n<p>We can make use of <a href=\"https://web.postman.com/\">Postman</a> to test the Dialogflow connection implemented above in the <code>dialogflow-response</code> route. <a href=\"https://web.postman.com/\">Postman</a> is a collaboration platform for API development with features to test APIs built in either development or production stages.</p>\n<p><strong>Note:</strong> <em>If not already installed, the Postman desktop application is not needed to test an API. Starting from September 2020, Postman‚Äôs web client moved into a Generally Available (GA) state and can be used directly from a browser.</em>  </p>\n<p>Using the Postman Web Client, we can either create a new workspace or use an existing one to create a <code>POST</code> request to our API endpoint at <code>http://localhost:5000/api/agent/text-input</code>  and add data with a key of <code>message</code> and value of ‚Äú<strong>Hi There</strong>‚Äù into the query parameters. </p>\n<p>At the click of the <strong>Send</strong> button, a <code>POST</code> request will be made to the running Express server ‚Äî with a response similar to the one shown in the image below:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a04edd9f-11a2-47db-971c-6cda20fa2eb6/postman-test.png\" /></p>\n<p>Within the image above, we can see the prettified response data from the Dialogflow agent through the Express server. The data returned is formatted according to the <a href=\"https://developers.google.com/assistant/conversational/df-asdk/reference/dialogflow-webhook-json#simple-response-example-df\">sample response</a> definition given in the Dialogflow <a href=\"https://developers.google.com/assistant/conversational/df-asdk/reference/dialogflow-webhook-json#simple-response-example-df\">Webhook documentation</a>.</p>\n<h4>Handling Voice Inputs</h4>\n\n<p>By default, all Dialogflow agents are enabled to process both text and audio data and also return a response in either text or audio format. However, working with audio input or output data can be a bit more complex than text data. </p>\n<p>To handle and process voice inputs, we will begin the implementation for the <code>/voice-input</code> endpoint that we have previously created in order to receive audio files and send them to Dialogflow in exchange for a response from the Agent:</p>\n<pre><code>// agentRoutes.js\nimport { pipeline, Transform } from \"stream\";\nimport busboy from \"connect-busboy\";\nimport util from \"promisfy\"\nimport Dialogflow from \"@google-cloud/dialogflow\"\n\nconst app = express();\n\napp.use(\n  busboy({\n    immediate: true,\n  })\n);\n\napp.post(\"/voice-input\", (req, res) =&gt; {\n  const sessionClient = new Dialogflow.SessionsClient({\n    keyFilename: Path.join(__dirname, \"./recommender-key.json\"),\n  });\n  const sessionPath = sessionClient.projectAgentSessionPath(\n    process.env.PROJECT_ID,\n    uuid()\n  );\n\n  // transform into a promise\n  const pump = util.promisify(pipeline);\n\n  const audioRequest = {\n    session: sessionPath,\n    queryInput: {\n      audioConfig: {\n        audioEncoding: \"AUDIO_ENCODING_OGG_OPUS\",\n        sampleRateHertz: \"16000\",\n        languageCode: \"en-US\",\n      },\n      singleUtterance: true,\n    },\n  };\n\n  const streamData = null;\n  const detectStream = sessionClient\n    .streamingDetectIntent()\n    .on(\"error\", (error) =&gt; console.log(error))\n    .on(\"data\", (data) =&gt; {\n      streamData = data.queryResult    \n    })\n    .on(\"end\", (data) =&gt; {\n      res.status(200).send({ data : streamData.fulfillmentText }}\n    }) \n\n  detectStream.write(audioRequest);\n\n  try {\n    req.busboy.on(\"file\", (_, file, filename) =&gt; {\n      pump(\n        file,\n        new Transform({\n          objectMode: true,\n          transform: (obj, _, next) =&gt; {\n            next(null, { inputAudio: obj });\n          },\n        }),\n        detectStream\n      );\n    });\n  } catch (e) {\n    console.log(`error  : ${e}`);\n  }\n});\n</code></pre>\n\n<p>At a high overview, the <code>/voice-input</code> route above receives a user‚Äôs voice input as a file containing the message being spoken to the chat assistant and sends it to the Dialogflow agent. To understand this process better, we can break it down into the following smaller steps:</p>\n<ul>\n<li>First, we add and use <a href=\"https://www.npmjs.com/package/connect-busboy\">connect-busboy</a> as an <a href=\"https://expressjs.com/en/guide/using-middleware.html\">Express middleware</a> for parsing form data being sent in the request from the web application. After which we authenticate with Dialogflow using the Service Key and create a session, the same way we did in the previous route.<br />Then using the <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/util.html\">promisify</a> method from the built-in <a href=\"https://nodejs.org/\">Node.js</a> <a href=\"https://nodejs.org/api/util.html\">util</a> module, we get and save a promise equivalent of the Stream pipeline method to be used later to pipe multiple streams and also perform a clean up after the streams are completed.</li>\n<li>Next, We create a request object containing the Dialogflow authentication session and a configuration for the audio file about to be sent to Dialogflow. The nested audio configuration object enables the Dialogflow agent to perform a <a href=\"https://cloud.google.com/speech-to-text\">Speech-To-Text</a> conversion on the sent audio file. </li>\n<li>Next, using the created session and the request object, we detect a user‚Äôs intent from the audio file using <code>detectStreamingIntent</code> method which opens up a new data stream from the Dialogflow agent to the backend application. Data will send back in small bits through this stream and using the data ‚Äú<strong>event</strong>‚Äù from the readable stream we store the data in  <code>streamData</code> variable for later use. After the stream is closed the ‚Äú<strong>end</strong>‚Äù event is fired and we send the response from the Dialogflow agent stored in the <code>streamData</code>  variable to the Web Application.</li>\n<li>Lastly using the file stream event from <a href=\"https://www.npmjs.com/package/connect-busboy\">connect-busboy</a>, we receive the stream of the audio file sent in the request body and we further pass it into the promise equivalent of Pipeline which we created previously. The function of this is to pipe the audio file stream coming in from request to the Dialogflow stream, we pipe the audio file stream to the stream opened by the <code>detectStreamingIntent</code> method above.</li>\n</ul>\n<p>To test and confirm that the steps above are working as laid out, we can make a test request containing an audio file in the request body to the <code>/voice-input</code> endpoint using Postman. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/236d6e74-9023-4e43-b379-e1a61f824bc9/testing-voice-input-route.png\" /></p>\n<p>The Postman result above shows the response gotten after making a POST request with the form-data of a recorded voice note message saying ‚Äú<strong>Hi</strong>‚Äù included in the request‚Äôs body. </p>\n<p>At this point, we now have a functional Express.js application that sends and receives data from Dialogflow, the two parts of this article are done. Where are now left with integrating this Agent into a web application by consuming the APIs created here from a <a href=\"https://reactjs.org/\">Reactjs</a> application.</p>\n<h3>Integrating Into A Web Application</h3>\n\n<p>To consume our built REST API we will expand <a href=\"https://wines-list.netlify.app/\">this</a> existing React.js application which already has a home page showing a list of wines fetched from an API and support for decorators using the <a href=\"https://babeljs.io/docs/en/babel-plugin-proposal-decorators\">babel proposal decorators plugin</a>. We will refactor it a little by introducing <a href=\"https://mobx.js.org/README.html\">Mobx</a> for state management and also a new feature to recommend a wine from a chat component using the added REST API endpoints from the Express.js application.</p>\n<p>To get started, we begin to manage the application‚Äôs state using <a href=\"https://mobx.js.org/README.html\">MobX</a> as we create a Mobx store with a few <a href=\"https://mobx.js.org/api.html#observablearray\">observable</a> values and some methods as <a href=\"https://mobx.js.org/api.html#action\">actions</a>.</p>\n<div>\n<pre><code>// store.js\n\nimport Axios from \"axios\";\nimport { action, observable, makeObservable, configure } from \"mobx\";\n\nconst ENDPOINT = process.env.REACT_APP_DATA_API_URL;\n\nclass ApplicationStore {\n  constructor() {\n    makeObservable(this);\n  }\n\n  @observable\n  isChatWindowOpen = false;\n\n  @observable\n  isLoadingChatMessages = false;\n\n  @observable\n  agentMessages = [];\n\n  @action\n  setChatWindow = (state) =&gt; {\n    this.isChatWindowOpen = state;\n  };\n\n  @action\n  handleConversation = (message) =&gt; {\n     this.isLoadingChatMessages = true;\n     this.agentMessages.push({ userMessage: message });\n\n     Axios.post(<code>${ENDPOINT}/dialogflow-response</code>, {\n      message: message || \"Hi\",\n     })\n      .then((res) =&gt; {\n        this.agentMessages.push(res.data.data[0].queryResult);\n        this.isLoadingChatMessages = false;\n      })\n      .catch((e) =&gt; {\n        this.isLoadingChatMessages = false;\n        console.log(e);\n      });\n  };\n}\n\nexport const store = new ApplicationStore();</code></pre>\n</div>\n\n<p>Above we created a store for the chat component feature within the application having the following values: </p>\n<ul>\n<li><code>isChatWindowOpen</code><br />The value stored here controls the visibility of the chat component where the messages of Dialogflow are shown.</li>\n<li><code>isLoadingChatMessages</code><br />This is used to show a loading indicator when a request to fetch a response from the Dialogflow agent is made.</li>\n<li><code>agentMessages</code><br />This array stores all responses coming from the requests made to get a response from the Dialogflow agent. The data in the array is later displayed in the component.</li>\n<li><code>handleConversation</code><br />This method decorated as an action adds data into the <code>agentMessages</code> array. First, it adds the user‚Äôs message passed in as an argument then makes a request using <a href=\"https://github.com/axios/axios\">Axios</a> to the backend application to get a response from Dialogflow. After the request is resolved, it adds the response from the request into the <code>agentMessages</code> array. </li>\n</ul>\n<p><strong>Note:</strong> <em>In the absence of the</em> <a href=\"https://github.com/tc39/proposal-decorators\"><em>decorators</em></a> <em>support in an Application, MobX provides</em> <a href=\"https://mobx.js.org/api.html#makeobservable\"><em>makeObservable</em></a> <em>which can be used in the constructor of the target store class. See an example</em> <a href=\"https://mobx.js.org/observable-state.html#makeobservable\"><em>here</em></a>. </p>\n<p>With the store setup, we need to wrap the entire application tree with the MobX Provider higher-order component starting from the root component in the <code>index.js</code> file.</p>\n<pre><code>import React from \"react\";\nimport { Provider } from \"mobx-react\";\n\nimport { store } from \"./state/\";\nimport Home from \"./pages/home\";\n\nfunction App() {\n  return (\n    &lt;Provider ApplicationStore={store}&gt;\n      &lt;div className=\"App\"&gt;\n        &lt;Home /&gt;\n      &lt;/div&gt;\n    &lt;/Provider&gt;\n  );\n}\n\nexport default App;\n</code></pre>\n\n<p>Above we wrap the root App component with MobX Provider and we pass in the previously created store as one of the Provider‚Äôs values. Now we can proceed to read from the store within components connected to the store.</p>\n<h4>Creating A Chat Interface</h4>\n\n<p>To display the messages sent or received from the API requests, we need a new component with some chat interface showing the messages listed out. To do this, we create a new component to display some hard-coded messages first then later we display messages in an ordered list.</p>\n<pre><code>// ./chatComponent.js\n\nimport React, { useState } from \"react\";\nimport { FiSend, FiX } from \"react-icons/fi\";\nimport \"../styles/chat-window.css\";\n\nconst center = {\n  display: \"flex\",\n  jusitfyContent: \"center\",\n  alignItems: \"center\",\n};\n\nconst ChatComponent = (props) =&gt; {\n  const { closeChatwindow, isOpen } = props;\n  const [Message, setMessage] = useState(\"\");\n\n  return (\n   &lt;div className=\"chat-container\"&gt;\n      &lt;div className=\"chat-head\"&gt;\n        &lt;div style={{ ...center }}&gt;\n          &lt;h5&gt; Zara &lt;/h5&gt;\n        &lt;/div&gt;\n        &lt;div style={{ ...center }} className=\"hover\"&gt;\n          &lt;FiX onClick={() =&gt; closeChatwindow()} /&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div className=\"chat-body\"&gt;\n        &lt;ul className=\"chat-window\"&gt;\n          &lt;li&gt;\n            &lt;div className=\"chat-card\"&gt;\n              &lt;p&gt;Hi there, welcome to our Agent&lt;/p&gt;\n            &lt;/div&gt;\n          &lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;hr style={{ background: \"#fff\" }} /&gt;\n        &lt;form onSubmit={(e) =&gt; {}} className=\"input-container\"&gt;\n          &lt;input\n            className=\"input\"\n            type=\"text\"\n            onChange={(e) =&gt; setMessage(e.target.value)}\n            value={Message}\n            placeholder=\"Begin a conversation with our agent\"\n          /&gt;\n          &lt;div className=\"send-btn-ctn\"&gt;\n            &lt;div className=\"hover\" onClick={() =&gt; {}}&gt;\n              &lt;FiSend style={{ transform: \"rotate(50deg)\" }} /&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/form&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ChatComponent</code></pre>\n\n<p>The component above has the basic HTML markup needed for a chat application. It has a header showing the Agent‚Äôs name and an icon for closing the chat window, a message bubble containing a hardcoded text in a list tag, and lastly an input field having an <code>onChange</code> event handler attached to the input field to store the text typed into the component‚Äôs local state using React‚Äôs <a href=\"https://reactjs.org/docs/hooks-reference.html#usestate\">useState</a>. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5cebbe94-2dea-4de2-8da5-ecc07d8391b0/chat-component-preview.png\" /></p>\n<p>From the image above, the chat component works as it should, showing a styled chat window having a single chat message and the input field at the bottom. We however want the message shown to be actual responses gotten from the API request and not hardcoded text.  </p>\n<p>We move forward to refactor the Chat component, this time connecting and making use of values in the MobX store within the component.</p>\n<div>\n<pre><code>// ./components/chatComponent.js\n\nimport React, { useState, useEffect } from \"react\";\nimport { FiSend, FiX } from \"react-icons/fi\";\nimport { observer, inject } from \"mobx-react\";\nimport { toJS } from \"mobx\";\nimport \"../styles/chat-window.css\";\n\nconst center = {\n  display: \"flex\",\n  jusitfyContent: \"center\",\n  alignItems: \"center\",\n};\n\nconst ChatComponent = (props) =&gt; {\n  const { closeChatwindow, isOpen } = props;\n  const [Message, setMessage] = useState(\"\");\n\n  const {\n    handleConversation,\n    agentMessages,\n    isLoadingChatMessages,\n  } = props.ApplicationStore;\n\n  useEffect(() =&gt; {\n    handleConversation();\n    return () =&gt; handleConversation()\n  }, []);\n\n  const data = toJS(agentMessages);\n\n  return (\n        &lt;div className=\"chat-container\"&gt;\n          &lt;div className=\"chat-head\"&gt;\n            &lt;div style={{ ...center }}&gt;\n              &lt;h5&gt; Zara {isLoadingChatMessages &amp;&amp; \"is typing ...\"} &lt;/h5&gt;\n            &lt;/div&gt;\n            &lt;div style={{ ...center }} className=\"hover\"&gt;\n              &lt;FiX onClick={(_) =&gt; closeChatwindow()} /&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"chat-body\"&gt;\n            &lt;ul className=\"chat-window\"&gt;\n              {data.map(({ fulfillmentText, userMessage }) =&gt; (\n                &lt;li&gt;\n                  {userMessage &amp;&amp; (\n                    &lt;div\n                      style={{\n                        display: \"flex\",\n                        justifyContent: \"space-between\",\n                      }}\n                    &gt;\n                      &lt;p style={{ opacity: 0 }}&gt; . &lt;/p&gt;\n                      &lt;div\n                        key={userMessage}\n                        style={{\n                          background: \"red\",\n                          color: \"white\",\n                        }}\n                        className=\"chat-card\"\n                      &gt;\n                        &lt;p&gt;{userMessage}&lt;/p&gt;\n                      &lt;/div&gt;\n                    &lt;/div&gt;\n                  )}\n                  {fulfillmentText &amp;&amp; (\n                    &lt;div\n                      style={{\n                        display: \"flex\",\n                        justifyContent: \"space-between\",\n                      }}\n                    &gt;\n                      &lt;div key={fulfillmentText} className=\"chat-card\"&gt;\n                        &lt;p&gt;{fulfillmentText}&lt;/p&gt;\n                      &lt;/div&gt;\n                      &lt;p style={{ opacity: 0 }}&gt; . &lt;/p&gt;\n                    &lt;/div&gt;\n                  )}\n                &lt;/li&gt;\n              ))}\n            &lt;/ul&gt;\n            &lt;hr style={{ background: \"#fff\" }} /&gt;\n            &lt;form\n              onSubmit={(e) =&gt; {\n                e.preventDefault();\n                handleConversation(Message);\n              }}\n              className=\"input-container\"\n            &gt;\n              &lt;input\n                className=\"input\"\n                type=\"text\"\n                onChange={(e) =&gt; setMessage(e.target.value)}\n                value={Message}\n                placeholder=\"Begin a conversation with our agent\"\n              /&gt;\n              &lt;div className=\"send-btn-ctn\"&gt;\n                &lt;div\n                  className=\"hover\"\n                  onClick={() =&gt; handleConversation(Message)}\n                &gt;\n                  &lt;FiSend style={{ transform: \"rotate(50deg)\" }} /&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/form&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n     );\n};\n\nexport default inject(\"ApplicationStore\")(observer(ChatComponent));\n</code></pre>\n</div>\n\n<p>From the highlighted parts of the code above, we can see that the entire chat component has now been modified to perform the following new operations;</p>\n<ul>\n<li>It has access to the MobX store values after injecting the <code>ApplicationStore</code> value. The component has also been made an observer of these store values so it re-renders when one of the values changes.</li>\n<li>We start the conversation with the Agent immediately after the chat component is opened by invoking the <code>handleConversation</code> method within a <code>useEffect</code> hook to make a request immediately the component is rendered.</li>\n<li>We are now making use of the <code>isLoadingMessages</code> value within the Chat component header. When a request to get a response from the Agent is in flight, we set the <code>isLoadingMessages</code> value to <code>true</code> and update the header to <strong>Zara is typing...</strong></li>\n<li>The <code>agentMessages</code> array within the store gets updated to a proxy by MobX after its values are set. From this component, we convert that proxy back to an array using the <code>toJS</code> utility from MobX and store the values in a variable within the component. That array is further iterated upon to populate the chat bubbles with the values within the array using a map function.</li>\n</ul>\n<p>Now using the chat component we can type in a sentence and wait for a response to be displayed in the agent.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/14e3f8f6-e88d-408c-84db-714fddc0dbfb/chat-component-messages.png\" /></p>\n<h4>Recording User Voice Input</h4>\n\n<p>By default, all Dialogflow agents can accept either voice or text-based input in any specified language from a user. However, it requires a few adjustments from a web application to gain access to a user‚Äôs microphone and record a voice input. </p>\n<p>To achieve this, we modify the MobX store to use the HTML <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API\">MediaStream Recording API</a> to record a user‚Äôs voice within two new methods in the MobX store.   </p>\n<pre><code>// store.js\n\nimport Axios from \"axios\";\nimport { action, observable, makeObservable } from \"mobx\";\n\nclass ApplicationStore {\n  constructor() {\n    makeObservable(this);\n  }\n\n  @observable\n  isRecording = false;\n\n  recorder = null;\n  recordedBits = [];\n\n  @action\n  startAudioConversation = () =&gt; {\n    navigator.mediaDevices\n      .getUserMedia({\n        audio: true,\n      })\n      .then((stream) =&gt; {\n        this.isRecording = true;\n        this.recorder = new MediaRecorder(stream);\n        this.recorder.start(50);\n\n        this.recorder.ondataavailable = (e) =&gt; {\n           this.recordedBits.push(e.data);\n        };\n      })\n      .catch((e) =&gt; console.log(`error recording : ${e}`));\n  };\n};\n</code></pre>\n\n<p>At the click of the record icon from the chat component, the <code>startAudioConversation</code> method in the MobX store above is invoked to set the method the observable <code>isRecording</code> property is to true , for the chat component to provide visual feedback to show a recording is in progress.</p>\n<p>Using the browser‚Äôs <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Navigator\">navigator</a> interface, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices\">Media Device</a> object is accessed to request the user‚Äôs device microphone. After permission is granted to the <code>getUserMedia</code> request, it resolves its promise with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaStream\">MediaStream</a> data which we further pass to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder\">MediaRecorder</a> constructor to create a recorder using the media tracks in the stream returned from the user‚Äôs device microphone. We then store the Media recorder instance in the store‚Äôs <code>recorder</code> property as we will access it from another method later on.</p>\n<p>Next, we call the start method on the recorder instance, and after the recording session is ended, the <code>ondataavailable</code> function is fired with an event argument containing the recorded stream in a Blob which we store in the <code>recordedBits</code> array property.</p>\n<p>Logging out the data in the event argument passed into the fired <code>ondataavailable</code> event, we can see the Blob and its properties in the browser console.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ee10f274-b1cf-4a93-8d71-9a16e949f29a/media-recorder-blob.png\" /></p>\n<p>Now that we can start a MediaRecorder stream, we need to be able to stop the MediaRecorder stream when a user is done recording their voice input and send the generated audio file to the Express.js application.</p>\n<p>The new method added to the store below stops the stream and makes a <code>POST</code> request containing the recorded voice input.</p>\n<div>\n<pre><code>//store.js\n\nimport Axios from \"axios\";\nimport { action, observable, makeObservable, configure } from \"mobx\";\n\nconst ENDPOINT = process.env.REACT_APP_DATA_API_URL;\n\nclass ApplicationStore {\n  constructor() {\n    makeObservable(this);\n  }\n\n  @observable\n  isRecording = false;\n\n  recorder = null;\n  recordedBits = []; \n\n  @action\n  closeStream = () =&gt; {\n    this.isRecording = false;\n    this.recorder.stop();\n\n    this.recorder.onstop = () =&gt; {\n      if (this.recorder.state === \"inactive\") {\n        const recordBlob = new Blob(this.recordedBits, {\n          type: \"audio/mp3\",\n        });\n\n        const inputFile = new File([recordBlob], \"input.mp3\", {\n          type: \"audio/mp3\",\n        });\n        const formData = new FormData();\n        formData.append(\"voiceInput\", inputFile);\n\n        Axios.post(<code>${ENDPOINT}/api/agent/voice-input</code>, formData, {\n          headers: {\n            \"Content-Type\": \"multipart/formdata\",\n          },\n        })\n          .then((data) =&gt; {})\n          .catch((e) =&gt; console.log(<code>error uploading audio file : ${e}</code>));\n      }\n    };\n  };\n}\n\nexport const store = new ApplicationStore();</code></pre>\n</div>\n\n<p>The method above executes the MediaRecorder‚Äôs stop method to stop an active stream. Within the <code>onstop</code> event fired after the MediaRecorder is stopped, we create a new <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\">Blob</a> with a music type and append it into a created <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\">FormData</a>. </p>\n<p>As the last step., we make <code>POST</code> request with the created Blob added to the request body and a <code>Content-Type: multipart/formdata</code> added to the request‚Äôs headers so the file can be parsed by the connect-busboy middleware from the backend-service application.</p>\n<p>With the recording being performed from the MobX store, all we need to add to the chat-component is a button to execute the MobX actions to start and stop the recording of the user‚Äôs voice and also a text to show when a recording session is active.</p>\n<pre><code>import React from 'react'\n\nconst ChatComponent = ({ ApplicationStore }) =&gt; {\n  const {\n     startAudiConversation,\n     isRecording,\n     handleConversation,\n     endAudioConversation,\n     isLoadingChatMessages\n    } = ApplicationStore\n\n  const [ Message, setMessage ] = useState(\"\") \n\n    return (\n        &lt;div&gt;\n           &lt;div className=\"chat-head\"&gt;\n            &lt;div style={{ ...center }}&gt;\n              &lt;h5&gt; Zara {} {isRecording &amp;&amp; \"is listening ...\"} &lt;/h5&gt;\n            &lt;/div&gt;\n            &lt;div style={{ ...center }} className=\"hover\"&gt;\n              &lt;FiX onClick={(_) =&gt; closeChatwindow()} /&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;          \n\n          &lt;form\n              onSubmit={(e) =&gt; {\n                  e.preventDefault();\n                  handleConversation(Message);\n                }}\n                className=\"input-container\"\n              &gt;\n                &lt;input\n                  className=\"input\"\n                  type=\"text\"\n                  onChange={(e) =&gt; setMessage(e.target.value)}\n                  value={Message}\n                  placeholder=\"Begin a conversation with our agent\"\n                /&gt;\n                &lt;div className=\"send-btn-ctn\"&gt;\n                  {Message.length &gt; 0 ? (\n                    &lt;div\n                      className=\"hover\"\n                      onClick={() =&gt; handleConversation(Message)}\n                    &gt;\n                      &lt;FiSend style={{ transform: \"rotate(50deg)\" }} /&gt;\n                    &lt;/div&gt;\n                  ) : (\n                    &lt;div\n                      className=\"hover\"\n                      onClick={() =&gt;  handleAudioInput()}\n                    &gt;\n                      &lt;FiMic /&gt;\n                    &lt;/div&gt;\n                  )}\n                &lt;/div&gt;\n              &lt;/form&gt;\n        &lt;/div&gt;     \n    )\n}\n\nexport default ChatComponent</code></pre>\n\n<p>From the highlighted part in the chat component header above, we use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\">ES6 ternary operators</a> to switch the text to ‚Äú<strong>Zara is listening ‚Ä¶.</strong>‚Äù whenever a voice input is being recorded and sent to the backend application. This gives the user feedback on what is being done.</p>\n<p>Also, besides the text input, we added a microphone icon to inform the user of the text and voice input options available when using the chat assistant. If a user decides to use the text input, we switch the microphone button to a Send button by counting the length of the text stored and using a ternary operator to make the switch. </p>\n<p>We can test the newly connected chat assistant a couple of times by using both voice and text inputs and watch it respond exactly like it would when using the Dialogflow console! </p>\n<h3>Conclusion</h3>\n\n<p>In the coming years, the use of language processing chat assistants in public services will have become mainstream. This article has provided a basic guide on how one of these chat assistants built with Dialogflow can be integrated into your own web application through the use of a backend application.</p>\n<p>The built application has been deployed using <a href=\"https://www.netlify.com/\">Netlify</a> and can be found <a href=\"https://wine-recommender.netlify.app/\">here</a>. Feel free to explore the Github repository of the backend express application <a href=\"https://github.com/vickywane/dialogflow-article-server\">here</a> and the React.js web application <a href=\"https://github.com/vickywane/dialogflow-article\">here</a>. They both contain a detailed README to guide you on the files within the two projects.  </p>\n<h4>References</h4>\n\n<ul>\n<li><a href=\"https://cloud.google.com/dialogflow/docs\">Dialogflow Documentation</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2020/12/conversational-nlp-enabled-chatbot-google-dialogflow/\">Building A Conversational N.L.P Enabled Chatbot Using Google‚Äôs Dialogflow</a> by Nwani Victory</li>\n<li><a href=\"https://mobx.js.org/\">MobX</a></li>\n<li><a href=\"https://web.postman.com/\">https://web.postman.com</a></li>\n<li><a href=\"https://www.npmjs.com/package/@google-cloud/dialogflow\">Dialogflow API: Node.js Client</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API/Using_the_MediaStream_Recording_API\">Using the MediaStream Recording API</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"4f79ebc284d87a3bc264fbb3d53e1cef58a8d388f4a06780f2cb5c50fdba15a8","category":"Tech"}