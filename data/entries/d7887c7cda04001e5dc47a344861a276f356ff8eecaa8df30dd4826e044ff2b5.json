{"title":"A Few Ways CSS Is Easier To Write In 2023","link":"https://smashingmagazine.com/2023/11/few-ways-css-easier-write-2023/","date":1700812800000,"content":"<p>A little while back, I poked at a number of <a href=\"https://geoffgraham.me/what-exactly-is-modern-css/\">‚Äúmodern‚Äù CSS</a> features and <a href=\"https://www.smashingmagazine.com/2023/07/writing-css-2023/\">openly evaluated</a> whether or not they have really influenced the way I write styles.</p>\n<p><strong>Spoiler alert:</strong> The answer is not <em>much</em>. Some, but not to the extent that the styles I write today would look foreign when held side-by-side with a stylesheet from two or three years ago.</p>\n<p>That was a fun thought process but more academic than practicum. As I continue thinking about how I approach CSS today, I‚Äôm realizing that the differences are a lot more subtle than I may have expected ‚Äî or have even noticed.</p>\n<p>CSS has gotten easier to write than it is different to write.</p>\n<p>And that‚Äôs not because of one hot screaming new feature that changes everything ‚Äî say, Cascade Layers or new color spaces ‚Äî but how many of the new features <em>work together</em> to make my styles more succinct, resilient, and even slightly defensive.</p>\n<p>Let me explain.</p>\nEfficient Style Groups\n<p>Here‚Äôs a quick hit. Rather than chaining <code>:hover</code> and <code>:focus</code> states together with comma separation, using the newer <code>:is()</code> pseudo-class makes it a more readable one-liner:</p>\n<pre><code>/* Tradition */\na:hover,\na:focus {\n  /* Styles */\n}\n\n/* More readable */\na:is(:hover, :focus) {\n  /* Styles */\n}\n</code></pre>\n\n<p>I say ‚Äúmore readable‚Äù because it‚Äôs not exactly more efficient. I simply like how it reads as normal conversation: <em>An anchor that is in hover or in focus is styled like this...</em></p>\n<p>Of course, <code>:is()</code> can most definitely make for a more efficient selector. Rather than make up some crazy example, <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:is#simplifying_list_selectors\">you can check out MDN‚Äôs example</a> to see the efficiency powers of <code>:is()</code> and rejoice.</p>\nCentering\n<p>This is a classic example, right? The ‚Äútraditional‚Äù approach for aligning an element in the center of its parent container was usually a no-brainer, so to speak. We reached for some variety of <code>margin: auto</code> to push an element from all sides inward until it sits plumb in the middle.</p>\n<p>That‚Äôs still an extremely effective solution for centering, as the <code>margin</code> shorthand looks at every direction. But say we only need to work in the <em>inline</em> direction, as in left and right, when working in a default horizontal left-to-write writing mode. That‚Äôs where the ‚Äútraditional‚Äù approach falls apart a bit.</p>\n<pre><code>/* Traditional */\nmargin-left: auto;\nmargin-right: auto;\n</code></pre>\n\n<p>Maybe ‚Äúfalls apart‚Äù is heavy-handed. It‚Äôs more that it requires dropping the versatile <code>margin</code> shorthand and reaching specifically for two of its constituent properties, adding up to one more line of overhead. But, thanks to the concept of <strong>logical properties</strong>, we get two more shorthands of the <code>margin</code> variety: one for the <em>block</em> direction and one for the <em>inline</em> direction. So, going back to a situation where centering only needs to happen in the inline direction, we now have this to keep things efficient:</p>\n<pre><code>/* Easier! */\nmargin-inline: auto;\n</code></pre>\n\n<p>And you know what else? The simple fact that this example makes the subtle transition from physical properties to logical ones means that this little snippet is both as equally efficient as throwing <code>margin: auto</code> out there and resilient to changes in the writing mode. If the page suddenly finds itself in a vertical right-to-left mode, it still holds up by automatically centering the element in the inline direction when the inline direction flows up and down rather than left and right.</p>\nAdjusting For Writing Modes, In General\n<p>I‚Äôve already extolled the virtues of logical properties. They actually may influence how I write CSS today more than any other CSS feature since Flexbox and CSS Grid.</p>\n<p>I certainly believe logical properties don‚Äôt get the credit they deserve, likely because document flow is a lot less exciting than, say, things like custom properties and container queries.</p>\n<p>Traditionally, we might write one set of styles for whatever is the ‚Äúnormal‚Äù writing direction, then target the writing mode on the HTML level using <code>[dir=\"rtl\"]</code> or whatever. Today, though, forget all that and use logical properties instead. That way, the layout follows the writing mode!</p>\n<p>So, where we may normally need to reset a physical margin when changing writing modes like this:</p>\n<pre><code>/* Traditional */\nbody {\n  margin-left: 1rem;\n}\n\nbody[dir=\"rtl\"] {\n  margin-left: 0; /* reset left margin */\n  margin-right: 1rem; /* apply to the right */\n  text-align: right; /* push text to the other side */\n}\n</code></pre>\n\n<p>... there‚Äôs no longer a need to rest things as long as we‚Äôre working with logical properties:</p>\n<pre><code>/* Much easier! */\nbody {\n  margin-inline-start: 1rem;\n}\n</code></pre>\n\nTrimming Superfluous Spacing\n<p>Here‚Äôs another common pattern. I‚Äôm sure you‚Äôve used an unordered list of links inside of a <code>&lt;nav&gt;</code> for the main or global navigation of a project.</p>\n<pre><code>&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"/products\"&gt;Products&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"/products\"&gt;Services&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"/products\"&gt;Docs&lt;/a&gt;&lt;/li&gt;\n    &lt;!-- etc. --&gt;\n  &lt;ul&gt;\n&lt;/nav&gt;\n</code></pre>\n\n<p>And in those cases, I‚Äôm sure you‚Äôve been asked to display those links side-by-side rather than allowing them to stack vertically as an unordered list is naturally wont to do. Some of us who have been writing styles for some years may have muscle memory for changing the <code>display</code> of those list items from default block-level elements into inline elements while preserving the box model properties of block elements:</p>\n<pre><code>/* Traditional */\nli {\n  display: inline-block;\n}\n</code></pre>\n\n<p>You‚Äôre going to need space between those list items. After all, they no longer take up the full available width of their parent since <code>inline-block</code> elements are only as wide as the content they contain, plus whatever borders, padding, margin, and offsets we add. Traditionally, that meant reaching for <code>margin</code> as we do for centering, but only the constituent <code>margin</code> property that applies the margin in the inline direction we want, whether that is <code>margin-left</code>/<code>margin-inline-start</code> or <code>margin-right</code>/<code>margin-inline-end</code>.</p>\n<p>Let‚Äôs assume we‚Äôre working with logical properties and want a margin at the end of the list of items in the inline direction:</p>\n<pre><code>/* Traditional */\nli {\n  display: inline-block;\n  margin-inline-end: 1rem;\n}\n</code></pre>\n\n<p>But wait! Now we have margin on <em>all</em> of the list items. There‚Äôs really no need for a margin on the last list item because, well, there are no other items after it.</p>\n<p><img src=\"https://files.smashing.media/articles/few-ways-css-easier-write-2023/1-margin-trim.png\" /></p>\n<p>That may be cool in the vast majority of situations, but it leaves the layout susceptible. What if, later, we decide to display another element next to the <code>&lt;nav&gt;</code>? Suddenly, we‚Äôre dealing with superfluous spacing that might affect how we decide to style that new element. It‚Äôs a form of <a href=\"https://css-tricks.com/defining-and-dealing-with-technical-debt/\">technical debt</a>.</p>\n<p>It would be better to clean that up and tackle spacing for reals without that worry. We could reach for a more modern feature like the <code>:not()</code> pseudo-class. That way, we can <em>exclude</em> the last list item from participating in the margin party.</p>\n<pre><code>/* A little more modern */\nli {\n  display: inline-block;\n}\nli:not(:last-of-type) {\n  margin-inline-end: 1rem;\n}\n</code></pre>\n\n<p>Even easier? Even <em>more</em> modern? We could reach for the <code>margin-trim</code> property, which, when applied to the parent element, chops off superfluous spacing like a good haircut, effectively collapsing margins that prevent the child elements from sitting flush with the parent‚Äôs edges.</p>\n<pre><code>/* Easier, more modern */\nul {\n  margin-trim: inline-end;\n}\n\nli {\n  display: inline-block;\n  margin-inline-end: 1rem;\n}\n</code></pre>\n\n<p>Before any pitchforks are raised, let‚Äôs note that <code>margin-trim</code> is experimental and <a href=\"https://caniuse.com/mdn-css_properties_margin-trim\">only supported by Safari</a> at the time I‚Äôm writing this. So, yes, this is <em>bleeding-edge</em> modern stuff and not exactly the sort of thing you want to ship straight to production. Just because something is ‚Äúmodern‚Äù doesn‚Äôt mean it‚Äôs the right tool for the job!</p>\n<p>In fact, there‚Äôs probably an even better solution without all the caveats, and it‚Äôs been sitting right under our noses: <strong>Flexbox</strong>. Turning the unordered list into a flexible container overrides the default block-level flow of the list items without changing their display, giving us the side-by-side layout we want. Plus, we gain access to the <code>gap</code> property, which you might think of as <code>margin</code> with <code>margin-trim</code> built right in because it only applies space <em>between</em> the children rather than all sides of them.</p>\n<pre><code>/* Less modern, but even easier! */\nul {\n  display: flex;\n  gap: 1rem;\n}\n</code></pre>\n\n<p>This is what I love about CSS. It‚Äôs poetic in the sense that <a href=\"https://css-tricks.com/hearts-in-html-and-css/\">there are many ways to say the same thing</a> ‚Äî some are more elegant than others ‚Äî but <strong>the ‚Äúbest‚Äù approach is the one that fits your thinking model</strong>. Don‚Äôt let anyone tell you you‚Äôre wrong if the output is what you‚Äôre expecting.</p>\n<p>Just because we‚Äôre on the topic of styling lists that don‚Äôt look like lists, it‚Äôs worth noting that the common task of removing list styles on both ordered and unordered lists (<code>list-style-type: none</code>) <a href=\"https://web.dev/articles/creative-list-styling#styling_lists_that_dont_look_like_lists\">has a side effect in Safari that strips the list items of its default accessible role</a>. One way to ‚Äúfix‚Äù it (if you consider it a breaking change) is to add the role back in HTML a l√† <code>&lt;ul role=\"list&gt;</code>. Manuel Matuzoviƒá has another approach that allows us to stay in CSS by <a href=\"https://matuzo.at/blog/2023/removing-list-styles-without-affecting-semantics\">removing the list style type with a value of empty quotes</a>:</p>\n<pre><code>ul {\n  list-style-type: \"\";\n}\n</code></pre>\n\n<p>I appreciate that Manuel not only shared the idea but has provided the results of light testing as well while noting that more testing might be needed to ensure it doesn‚Äôt introduce other latent consequences.</p>\nMaintaining Proportions\n<p>There‚Äôs no need to dwell on this one. We used to have very few options for maintaining an element‚Äôs physical proportions. For example, if you want a perfect square, you could rely on fixed pixel units explicitly declared on the element‚Äôs <code>width</code> and <code>height</code>:</p>\n<pre><code>/* Traditional */\nheight: 500px;\nwidth: 500px;\n</code></pre>\n\n<p>Or, perhaps you need the element‚Äôs size to flex a bit, so you prefer relative units. In that case, something like percentages is difficult because a value like <code>50%</code> is relative to the size of the element‚Äôs parent container rather than the element itself. The parent element then needs fixed dimensions or something else that‚Äôs completely predictable. It‚Äôs almost an infinite loop of trying to maintain the 1:1 proportion of one element by setting the proportion of another containing element.</p>\n<p>The so-called ‚ÄúPadding Hack‚Äù sure was a clever workaround and not really much of a ‚Äúhack‚Äù as much as a display of masterclass-level command of the CSS Box Model. Its origins <a href=\"https://alistapart.com/article/creating-intrinsic-ratios-for-video/\">date back to 2009</a>, but <a href=\"https://css-tricks.com/aspect-ratio-boxes/\">Chris Coyier explained it nicely in 2017</a>:</p>\n<blockquote>‚ÄúIf we force the height of the element to zero (<code>height: 0;</code>) and don‚Äôt have any borders, then the padding will be the only part of the box model affecting the height, and we‚Äôll have our square.‚Äù<br /><br />‚Äî Chris Coyier</blockquote>\n\n<p>Anyway, it took a lot of ingenious CSS to pull it off. Let‚Äôs hear it for the CSS Working Group, which came up with a much more elegant solution: an <code>aspect-ratio</code> property.</p>\n<pre><code>/* Easier! */\naspect-ratio: 1;\nwidth: 50%;\n</code></pre>\n\n<p>Now, we have a perfect square no matter how the element‚Äôs width responds to its surroundings, providing us with an <strong>easier and more efficient ruleset that‚Äôs more resilient to change</strong>. I often find myself using <code>aspect-ratio</code> in place of an explicit <code>height</code> or <code>width</code> in my styles these days.</p>\nCard Hover Effects\n<p>Not really CSS-specific, but styling a hover effect on a card has traditionally been a convoluted process where we wrap the element in an <code>&lt;a&gt;</code> and hook into it to style the card accordingly on hover. But with <code>:has()</code> ‚Äî now supported in <a href=\"https://caniuse.com/css-has\">all major browsers as of Firefox 121</a>! ‚Äî we can put the link in the card as a child how it should be and style the card as a parent element when it *has* hover.</p>\n<pre><code>.card:has(:hover, :focus) {\n  /* Style away! */\n}\n</code></pre>\n\n<p>That‚Äôs way super cool, awesome, and easier to read than, say:</p>\n<pre><code>a.card-link:hover &gt; .card {\n  /* Style what?! */\n}\n</code></pre>\n\nCreating And Maintaining Color Palettes\n<p>A long, long time ago, I shared <a href=\"https://geoffgraham.me/naming-sass-color-variables/\">how I name color variables</a> in my Sass files. The point is that I defined variables with hexadecimal values, sort of like this in a more modern context using CSS variables instead of Sass:</p>\n<pre><code>/* Traditional */\n:root {\n  --black: #000;\n  --gray-dark: #333;\n  --gray-medium: #777;\n  --gray-light: #ccc;\n  --gray-lighter: #eaeaea;\n  --white: #fff;\n}\n</code></pre>\n\n<p>There‚Äôs nothing inherently wrong with this. Define colors how you want! But notice that what I was doing up there was manually setting a range of grayscale colors and doing so with inflexible color values. As you might have guessed by this point, there is a more efficient way to set this up so that it is much more maintainable and even easier to read.</p>\n<div>\n<pre><code>/* Easier to maintain! */\n:root {\n  --primary-color: #000;\n  --gray-dark: color-mix(in srgb, var(--primary-color), #fff 25%);\n  --gray-medium: color-mix(in srgb, var(--primary-color), #fff 40%);\n  --gray-light: color-mix(in srgb, var(--primary-color), #fff 60%);\n  --gray-lighter: color-mix(in srgb, var(--primary-color), #fff 75%);\n}\n</code></pre>\n</div>\n\n<p>Those aren‚Äôt exactly 1:1 conversions. I‚Äôm too lazy to do it for real, but you get the idea, right? <em>Right?!</em> The ‚Äúeasier‚Äù way may *look* more complicated, but if you want to change the main color, update the <code>--primary-color</code> variable and call it a day.</p>\n<p>Perhaps a better approach would be to change the name <code>--primary-color</code> to <code>--grayscale-palette-base</code>. This way, we can use the same sort of approach across many other color scales for a robust color system.</p>\n<div>\n<pre><code>/* Easier to maintain! */\n:root {\n  /* Baseline Palette */\n  --black: hsl(0 0% 0%);\n  --white: hsl(0 0% 100%);\n  --red: hsl(11 100% 55%);\n  --orange: hsl(27 100% 49%);\n  /* etc. */\n\n  /* Grayscale Palette */\n  --grayscale-base: var(--black);\n  --grayscale-mix: var(--white);\n\n  --gray-100: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 75%);\n  --gray-200: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 60%);\n  --gray-300: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 40%);\n  --gray-400: color-mix(in srgb, var(--grayscale-base), var(--grayscale-mix) 25%);\n\n  /* Red Palette */\n  --red-base: var(--red);\n  --red-mix: var(--white);\n\n  --red-100: color-mix(in srgb, var(--red-base), var(--red-mix) 75%);\n  /* etc. */\n\n  /* Repeat as needed */\n}\n</code></pre>\n</div>\n\n<p>Managing color systems is a science unto itself, so please don‚Äôt take any of this as a prescription for how it‚Äôs done. The point is that we have <em>easier</em> ways to approach them these days, whereas we were forced to reach for non-CSS tooling to even get access to variables.</p>\nManaging Line Lengths\n<p>Two things that are pretty new to CSS that I‚Äôm absolutely loving:</p>\n<ul>\n<li>Character length units (<code>ch</code>);</li>\n<li><code>text-wrap: balance</code>.</li>\n</ul>\n<p>As far as the former goes, I love it for establishing the maximum width of containers, particularly those meant to hold long-form content. Conventional wisdom tells us that an ideal length for a line of text is <a href=\"https://baymard.com/blog/line-length-readability\">somewhere between 50-75 characters per line</a>, depending on your source. In a world where font sizing can <a href=\"https://www.smashingmagazine.com/2023/11/addressing-accessibility-concerns-fluid-type/\">adapt to the container size or the viewport size</a>, predicting how many characters will wind up on a line is a guessing game with a moving target. But if we set the container to a maximum width that never exceeds 75 characters via the <code>ch</code> unit and a minimum width that fills most, if not all, of the containing width in smaller contexts, that‚Äôs no longer an issue, and we can ensure a comfortable reading space at any breakpoint ‚Äî without media, to boot.</p>\n<pre><code>article {\n  width: min(100%, 75ch);\n}\n</code></pre>\n\n<p>Same sort of thing with headings. We don‚Äôt always have the information we need ‚Äî font size, container size, writing mode, and so on ‚Äî to produce a well-balanced heading. But you know who does? The browser! Using the new <a href=\"https://developer.chrome.com/blog/css-text-wrap-balance/\"><code>text-wrap: balance</code></a> value lets the browser decide when to wrap text in a way that prevents orphaned words or grossly unbalanced line lengths in a multi-line heading. This is another one of those cases where we‚Äôre waiting on complete browser support (<a href=\"https://caniuse.com/css-text-wrap-balance\">Safari, in this instance</a>). Still, it‚Äôs also one of those things I‚Äôm comfortable dropping into production now as a progressive enhancement since there‚Äôs no negative consequence with or without it.</p>\n<p>A word of caution, however, for those of you who may be tempted to apply this in a heavy-handed way across the board for <em>all</em> text:</p>\n<pre><code>/* üëé */\n* {\n  text-wrap: balance;\n}\n</code></pre>\n\n<p>Not only is that an un-performant decision, but the <code>balance</code> value is specced in a way that <a href=\"https://caniuse.com/css-text-wrap-balance\">ignores any text that is longer than ten lines</a>. The exact algorithm, according to the spec, is up to the user agent and could be treated as the <code>auto</code> value if the maximum number of lines is exceeded.</p>\n<pre><code>/* üëç */\narticle:is(h1, h2, h3, h4, h5, h6) {\n  text-wrap: balance;\n}\n</code></pre>\n\n<p><code>text-wrap: pretty</code> is another one in experimentation at the moment. It sounds like it‚Äôs similar to <code>balance</code> but in a way that allows the browser to sacrifice some performance gains for layout considerations. However, I have not played with it, and support for it is even more limited than <code>balance</code>.</p>\nHow About You?\n<p>These are merely the things that CSS offers here in late 2023 that I feel are having the most influence on how I write styles today versus how I may have approached similar situations back in the day when, during writing, I had to walk uphill both ways to produce a stylesheet.</p>\n<p>I can think of other features that I‚Äôve used but haven‚Äôt fully adopted in my toolset. Those would include things like the following:</p>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2022/01/introduction-css-cascade-layers/\">Cascade Layers</a> used mostly in CodePen demos.</li>\n<li><a href=\"https://www.smashingmagazine.com/2021/05/complete-guide-css-container-queries/\">Container Queries</a> in isolated cases as I continue to wrap my head around them.</li>\n<li><a href=\"https://www.smashingmagazine.com/2023/06/advanced-form-control-styling-selectmenu-anchoring-api/\"><code>&lt;selectmenu&gt;</code></a> which, OK, is HTML; but HTML that extends CSS powers.</li>\n<li><a href=\"https://developer.chrome.com/articles/css-nesting/\">CSS Nesting</a>, but I‚Äôm sure that‚Äôs bound to make its way into my work.</li>\n</ul>\n<p>What say you? I know there was a period of time when some of us were openly questioning whether there‚Äôs <a href=\"https://css-tricks.com/is-there-too-much-css-now/\">‚Äútoo much‚Äù CSS these days</a> and opining that the learning curve for getting into CSS is becoming a difficult barrier to entry for new front-enders. What new features are you finding yourself using, and are they helping you write CSS in new and different ways that make your code easier to read and maintain or perhaps ‚Äúre-learning‚Äù how you think about styles?</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"d7887c7cda04001e5dc47a344861a276f356ff8eecaa8df30dd4826e044ff2b5","category":"Tech"}