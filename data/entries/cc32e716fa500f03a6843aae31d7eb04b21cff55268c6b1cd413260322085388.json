{"title":"Building And Dockerizing A Node.js App With Stateless Architecture With Help From Kinsta","link":"https://smashingmagazine.com/2023/04/building-dockerizing-nodejs-app-stateless-architecture-kinsta/","date":1681992000000,"content":"<p>This article is a sponsored by <a href=\"https://kinsta.com/?utm_source=smashing&amp;utm_medium=digital&amp;utm_campaign=application-hosting&amp;utm_content=article\">Kinsta</a></p>\n<p>In this article, we‚Äôll take a swing at creating a stateless Node.js app and dockerizing it, making our development environment clean and efficient. Along the way, we‚Äôll explore the benefits of hosting containers on platforms like Kinsta that offers a managed hosting environment while supporting Docker containers as well as application and database hosting, enabling users to deploy and scale their applications with more flexibility and ease.</p>\nCreating A Node.js App\n<blockquote>In case you‚Äôre newer to code, Node.js is a platform built on Chrome‚Äôs JavaScript engine that allows developers to create server-side applications using JavaScript. It is popular for its lightweight nature, efficient performance, and asynchronous capabilities.</blockquote>\n\n<p>Stateless apps do not store any information about the user‚Äôs session, providing a clean and efficient way to manage your applications. Let‚Äôs explore how to create a Node.js app in this manner.</p>\n<h3>Step 1: Initialize The Node.js Project</h3>\n<p>First, create a new directory and navigate to it:</p>\n<pre><code>mkdir smashing-app &amp;&amp; cd smashing-app\n</code></pre>\n\n<p>Next, initialize a new Node.js project:</p>\n<pre><code>npm init -y</code></pre>\n\n<h3>Step 2: Install Express</h3>\n<p>Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. Install Express with the following command:</p>\n<pre><code>npm install express</code></pre>\n\n<h3>Step 3: Create Your Stateless App</h3>\n<p>Create a new file named ‚Äúapp.js‚Äù and add the following code:</p>\n<pre><code>const express = require(\"express\");\nconst app = express();\nconst port = process.env.PORT || 3000;\napp.get(\"/\", (req, res) =&gt; {\n  res.send(\"Welcome to our smashing stateless Node.js app!\");\n});\napp.listen(port, () =&gt; {\n  console.log(`Smashing app listening at http://localhost:${port}`);\n});\n</code></pre>\n\n<p>Let‚Äôs explore this a bit. Here‚Äôs what each line does:</p>\n<ul>\n<li><code>const express = require(\"express\");</code><br />This line imports the Express.js framework into the code, making it available to use.</li>\n<li><code>const app = express();</code><br />This line creates an instance of the Express.js framework called app. This app instance is where we define our server routes and configurations.</li>\n<li><code>const port = process.env.PORT || 3000;</code><br />This line sets the port number for the server. It looks for a port number set in an environment variable called PORT. If that variable is not set, it defaults to port 3000.</li>\n<li><code>app.get(\"/\", (req, res) =&gt; {}</code><br />This line defines a route for the server when a GET request is made to the root URL (‚Äú/‚Äù).</li>\n<li><code>res.send(\"Welcome to our smashing stateless Node.js app!\");</code><br />This line sends the string ‚ÄúWelcome to our smashing stateless Node.js app!‚Äù as a response to the GET request made to the root URL.</li>\n<li><code>app.listen(port, () =&gt; {})</code><br />This line starts the server and listens on the port number specified earlier.</li>\n</ul>\n<p>Now, run the app with:</p>\n<pre><code>node app.js</code></pre>\n\n<p>Your Node.js app is now running at <code>http://localhost:3000</code>.</p>\nStateless Architecture\n<p>Stateless architecture means that the server doesn‚Äôt store any information about the user‚Äôs session, resulting in several benefits:</p>\n<ul>\n<li><strong>Scalability</strong><br />Stateless applications can easily scale horizontally by adding more instances without worrying about session data.</li>\n<li><strong>Simplicity</strong><br />Without session data to manage, the application logic becomes simpler and easier to maintain.</li>\n<li><strong>Fault tolerance</strong><br />Stateless applications can recover quickly from failures because there‚Äôs no session state to be lost or recovered.</li>\n</ul>\n<p>Okay, we‚Äôve got our Node.js server running locally, but how can we package it up so that anyone can run it? Even people without Node.js installed, and have it run on any platform? That‚Äôs where Docker comes in.</p>\nDockerizing The App\n<p>Docker is a tool that helps developers build, ship, and run applications in a containerized environment. It simplifies the process of deploying applications across different platforms and environments.</p>\n<h3>Step 1: Install Docker</h3>\n<p>First, make sure you have Docker installed on your machine. You can download it <a href=\"https://docker.com/\">here</a>.</p>\n<h3>Step 2: Create A Dockerfile</h3>\n<p>Create a new file named Dockerfile in your project directory and add the following code:</p>\n<pre><code>FROM node:18-alpine\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nENV PORT=3000\nCMD [ \"node\", \"app.js\" ]\n</code></pre>\n\n<p>Once again, let‚Äôs take a look at what this is doing in a little more detail:</p>\n<ul>\n<li><code>FROM node:18-alpine</code><br />This line specifies the base image for this Docker image. In this case, it is the official Node.js Docker image based on the Alpine Linux distribution. This gives Node.js to the Docker container, which is like a ‚Äúvirtual machine‚Äù but lighter and more efficient.</li>\n<li><code>WORKDIR /usr/src/app</code><br />This line sets the working directory inside the Docker container to <code>/usr/src/app</code>.</li>\n<li><code>COPY . .</code><br />This line copies all the files from the local directory to the working directory in the Docker container.</li>\n<li><code>RUN npm install</code><br />This line installs the dependencies specified in the <code>package.json</code> file.</li>\n<li><code>ENV PORT=3000</code><br />Using this directive, we make the app more configurable by using the PORT environment variable. This approach provides flexibility and allows hosting providers like Kinsta to connect the application to their infrastructure seamlessly.</li>\n<li><code>CMD [ \"node\", \"app.js\" ]</code><br />This line specifies the command to run when the Docker container starts. In this case, it runs the node command with app.js as the argument, which will start the Node.js application.</li>\n</ul>\n<p>So, this Dockerfile builds a Docker image that sets up a working directory, installs dependencies, copies all the files into the container, exposes port 3000, and runs the Node.js application with the node command.</p>\n<h3>Step 3: Build And Run The Docker Container</h3>\n<p>Let‚Äôs now build this and run it locally to make sure everything works fine.</p>\n<pre><code>docker build -t smashing-app\n</code></pre>\n\n<p>When this succeeds, we will run the container:</p>\n<pre><code>docker run -p 3000:3000 smashing-app\n</code></pre>\n\n<p>Let‚Äôs break this down because that <code>-p 3000:3000</code> thing might look confusing. Here‚Äôs what‚Äôs happening:</p>\n<ol>\n<li><code>docker run</code> is a command used to run a Docker container.</li>\n<li><code>-p 3000:3000</code> is an option that maps port <code>3000</code> in the Docker container to port <code>3000</code> on the host machine. This means that the container‚Äôs port <code>3000</code> will be accessible from the host machine at port <code>3000</code>. The first port number is the host machine‚Äôs port number (ours), and the second port number is the container‚Äôs port number.</li>\n<li>We can have port <code>1234</code> on our machine mapped to port <code>3000</code> on the container, and then <code>localhost:1234</code> will point to <code>container:3000</code> and we'll still have access to the app.</li>\n<li><code>smashing-app</code> is the name of the Docker image that the container is based on, the one we just built.</li>\n</ol>\n<p>Your Dockerized Node.js app should now be running at <code><a href=\"http://localhost:3000\">http://localhost:3000</a></code>.</p>\n<p>When running the Docker container, we can additionally pass a custom PORT value as an environment variable:</p>\n<pre><code>docker run -p 8080:5713 -d -e PORT=5713 smashing-app\n</code></pre>\n\n<p>This command maps the container's port 5713 to the host's port 8080 and sets the PORT environment variable to 5713 inside the container.</p>\n<p>Using the PORT environment variable in the Dockerfile allows for greater flexibility and adaptability when deploying the Node.js app to various hosting providers, including <a href=\"https://kinsta.com/?utm_source=smashing&amp;utm_medium=digital&amp;utm_campaign=application-hosting&amp;utm_content=article\">Kinsta</a>.</p>\nMore Smashing Advantages Of Dockerizing A Node.js App\n<p>Dockerizing a Node.js app brings several advantages to developers and the overall application lifecycle. Here are some additional key benefits with code examples:</p>\n<h3>Simplified Dependency Management</h3>\n<p>Docker allows you to encapsulate all the dependencies within the container itself, making it easier to manage and share among team members. For example, let's say you have a package.json file with a specific version of a package:</p>\n<pre><code>{\n  \"dependencies\": {\n    \"lodash\": \"4.17.21\"\n  }\n}\n</code></pre>\n\n<p>By including this in your Dockerfile, the specific version of lodash is automatically installed and bundled within your container, ensuring consistent behavior across environments.</p>\n<h5>Easy App Versioning</h5>\n<p>Docker allows you to tag and version your application images, making it simple to roll back to previous versions or deploy different versions in parallel. For example, if you want to build a new version of your app, you can tag it using the following command:</p>\n<pre><code>docker build -t smashing-app:v2 .\n</code></pre>\n\n<p>You can then run multiple versions of your app simultaneously:</p>\n<pre><code>docker run -p 3000:3000 -d smashing-app:v1\n\ndocker run -p 3001:3000 -d smashing-app:v2\n</code></pre>\n\n<h5>Environment Variables</h5>\n<p>Docker makes it easy to manage environment variables, which can be passed to your Node.js app to modify its behavior based on the environment (development, staging, production). For example, in your app.js file:</p>\n<pre><code>const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst env = process.env.NODE_ENV || 'development';\napp.get('/', (req, res) =&gt; {\n  res.send(`Welcome to our smashing stateless Node.js app running in ${env} mode!`);\n});\napp.listen(port, () =&gt; {\n  console.log(`Smashing app listening at http://localhost:${port}`);\n});\n</code></pre>\n\n<p>In your Dockerfile, you can set the <code>NODE_ENV</code> variable:</p>\n<pre><code>FROM node:18-alpine\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nENV NODE_ENV=production\nCMD [ \"node\", \"app.js\" ]\n</code></pre>\n\n<p>Or you can pass it when running the container:</p>\n<pre><code>docker run -p 3000:3000 -d -e NODE_ENV=production smashing-app\n</code></pre>\n\n<p>The TL;DR of this is that through Dockerizing node apps, we can eliminate a whole class of ‚Äúworks on my machine‚Äù problems while also boosting the reusability, testability, and portability of our Node.js applications. üéâ</p>\nHosting Containers With Kinsta\n<p>Now that we have our stateless Node.js app Dockerized, you might be wondering where to host it. <a href=\"https://kinsta.com/?utm_source=smashing&amp;utm_medium=digital&amp;utm_campaign=application-hosting&amp;utm_content=article\">Kinsta</a> is widely known for its application and database hosting. Let‚Äôs explore how we‚Äôd do this with Kinsta in a step-by-step manner.</p>\n<ol>\n  <li>Login or sign-up to your Kinsta account.</li>\n  <li>From there, you should be in your dashboard.</li>\n  <li>Using the sidebar, navigate to <strong>Applications.</strong><br />\n\n<img src=\"https://files.smashing.media/articles/building-dockerizing-nodejs-app-stateless-architecture-kinsta/kinsta-sidebar-applications.jpg\" />\n</li>\n<li>From here, you should be able to Add a Service of type <strong>application</strong>.</li>\n<li>Once you add an application, you‚Äôll be invited to connect your GitHub account to Kinsta so that Kinsta can automatically deploy your application when updates are pushed to it.</li>\n<li>You can now choose the repo containing the code you‚Äôd like to deploy, along with setting some basic details like the application‚Äôs name and environment variables.<br />\n\n<img src=\"https://files.smashing.media/articles/building-dockerizing-nodejs-app-stateless-architecture-kinsta/kinsta-adding-application.png\" />\n</li>\n<li>Next, we specify the build environment of our application. It is here we specify the location of the Dockerfile in our repo that we just created.</li>\n<li>Finally, we allocate computer resources for our container, enter our payment information, and we‚Äôre ready to go!</li>\n</ol>\n\n<p>Kinsta will now build and deploy our application, and give us a public, secure link from where it is accessible. Our application is now published to the web!</p>\nConclusion\n<p>In this tutorial, we‚Äôve built a Node.js app and Dockerized it, making it easy to deploy across various environments. We‚Äôve also explored the benefits of stateless architecture and touched upon some great choices for hosting containers, like <a href=\"https://kinsta.com/?utm_source=smashing&amp;utm_medium=digital&amp;utm_campaign=application-hosting&amp;utm_content=article\">Kinsta</a>.</p>","author":"","siteTitle":"Articles on Smashing Magazine ‚Äî For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"cc32e716fa500f03a6843aae31d7eb04b21cff55268c6b1cd413260322085388","category":"Tech"}